{"version":3,"file":"1268.c0db87121614fb11733c.js?v=c0db87121614fb11733c","mappings":"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","sources":["webpack://@jupyterlab/application-top/./node_modules/@lezer/generator/dist/index.js"],"sourcesContent":["import { NodeProp } from '@lezer/common';\nimport { LRParser, LocalTokenGroup } from '@lezer/lr';\n\nclass Node {\n    constructor(start) {\n        this.start = start;\n    }\n}\nclass GrammarDeclaration extends Node {\n    constructor(start, rules, topRules, tokens, localTokens, context, externalTokens, externalSpecializers, externalPropSources, precedences, mainSkip, scopedSkip, dialects, externalProps, autoDelim) {\n        super(start);\n        this.rules = rules;\n        this.topRules = topRules;\n        this.tokens = tokens;\n        this.localTokens = localTokens;\n        this.context = context;\n        this.externalTokens = externalTokens;\n        this.externalSpecializers = externalSpecializers;\n        this.externalPropSources = externalPropSources;\n        this.precedences = precedences;\n        this.mainSkip = mainSkip;\n        this.scopedSkip = scopedSkip;\n        this.dialects = dialects;\n        this.externalProps = externalProps;\n        this.autoDelim = autoDelim;\n    }\n    toString() { return Object.values(this.rules).join(\"\\n\"); }\n}\nclass RuleDeclaration extends Node {\n    constructor(start, id, props, params, expr) {\n        super(start);\n        this.id = id;\n        this.props = props;\n        this.params = params;\n        this.expr = expr;\n    }\n    toString() {\n        return this.id.name + (this.params.length ? `<${this.params.join()}>` : \"\") + \" -> \" + this.expr;\n    }\n}\nclass PrecDeclaration extends Node {\n    constructor(start, items) {\n        super(start);\n        this.items = items;\n    }\n}\nclass TokenPrecDeclaration extends Node {\n    constructor(start, items) {\n        super(start);\n        this.items = items;\n    }\n}\nclass TokenConflictDeclaration extends Node {\n    constructor(start, a, b) {\n        super(start);\n        this.a = a;\n        this.b = b;\n    }\n}\nclass TokenDeclaration extends Node {\n    constructor(start, precedences, conflicts, rules, literals) {\n        super(start);\n        this.precedences = precedences;\n        this.conflicts = conflicts;\n        this.rules = rules;\n        this.literals = literals;\n    }\n}\nclass LocalTokenDeclaration extends Node {\n    constructor(start, precedences, rules, fallback) {\n        super(start);\n        this.precedences = precedences;\n        this.rules = rules;\n        this.fallback = fallback;\n    }\n}\nclass LiteralDeclaration extends Node {\n    constructor(start, literal, props) {\n        super(start);\n        this.literal = literal;\n        this.props = props;\n    }\n}\nclass ContextDeclaration extends Node {\n    constructor(start, id, source) {\n        super(start);\n        this.id = id;\n        this.source = source;\n    }\n}\nclass ExternalTokenDeclaration extends Node {\n    constructor(start, id, source, tokens) {\n        super(start);\n        this.id = id;\n        this.source = source;\n        this.tokens = tokens;\n    }\n}\nclass ExternalSpecializeDeclaration extends Node {\n    constructor(start, type, token, id, source, tokens) {\n        super(start);\n        this.type = type;\n        this.token = token;\n        this.id = id;\n        this.source = source;\n        this.tokens = tokens;\n    }\n}\nclass ExternalPropSourceDeclaration extends Node {\n    constructor(start, id, source) {\n        super(start);\n        this.id = id;\n        this.source = source;\n    }\n}\nclass ExternalPropDeclaration extends Node {\n    constructor(start, id, externalID, source) {\n        super(start);\n        this.id = id;\n        this.externalID = externalID;\n        this.source = source;\n    }\n}\nclass Identifier extends Node {\n    constructor(start, name) {\n        super(start);\n        this.name = name;\n    }\n    toString() { return this.name; }\n}\nclass Expression extends Node {\n    walk(f) { return f(this); }\n    eq(_other) { return false; }\n}\nExpression.prototype.prec = 10;\nclass NameExpression extends Expression {\n    constructor(start, id, args) {\n        super(start);\n        this.id = id;\n        this.args = args;\n    }\n    toString() { return this.id.name + (this.args.length ? `<${this.args.join()}>` : \"\"); }\n    eq(other) {\n        return this.id.name == other.id.name && exprsEq(this.args, other.args);\n    }\n    walk(f) {\n        let args = walkExprs(this.args, f);\n        return f(args == this.args ? this : new NameExpression(this.start, this.id, args));\n    }\n}\nclass SpecializeExpression extends Expression {\n    constructor(start, type, props, token, content) {\n        super(start);\n        this.type = type;\n        this.props = props;\n        this.token = token;\n        this.content = content;\n    }\n    toString() { return `@${this.type}[${this.props.join(\",\")}]<${this.token}, ${this.content}>`; }\n    eq(other) {\n        return this.type == other.type && Prop.eqProps(this.props, other.props) && exprEq(this.token, other.token) &&\n            exprEq(this.content, other.content);\n    }\n    walk(f) {\n        let token = this.token.walk(f), content = this.content.walk(f);\n        return f(token == this.token && content == this.content ? this : new SpecializeExpression(this.start, this.type, this.props, token, content));\n    }\n}\nclass InlineRuleExpression extends Expression {\n    constructor(start, rule) {\n        super(start);\n        this.rule = rule;\n    }\n    toString() {\n        let rule = this.rule;\n        return `${rule.id}${rule.props.length ? `[${rule.props.join(\",\")}]` : \"\"} { ${rule.expr} }`;\n    }\n    eq(other) {\n        let rule = this.rule, oRule = other.rule;\n        return exprEq(rule.expr, oRule.expr) && rule.id.name == oRule.id.name && Prop.eqProps(rule.props, oRule.props);\n    }\n    walk(f) {\n        let rule = this.rule, expr = rule.expr.walk(f);\n        return f(expr == rule.expr ? this :\n            new InlineRuleExpression(this.start, new RuleDeclaration(rule.start, rule.id, rule.props, [], expr)));\n    }\n}\nclass ChoiceExpression extends Expression {\n    constructor(start, exprs) {\n        super(start);\n        this.exprs = exprs;\n    }\n    toString() { return this.exprs.map(e => maybeParens(e, this)).join(\" | \"); }\n    eq(other) {\n        return exprsEq(this.exprs, other.exprs);\n    }\n    walk(f) {\n        let exprs = walkExprs(this.exprs, f);\n        return f(exprs == this.exprs ? this : new ChoiceExpression(this.start, exprs));\n    }\n}\nChoiceExpression.prototype.prec = 1;\nclass SequenceExpression extends Expression {\n    constructor(start, exprs, markers, empty = false) {\n        super(start);\n        this.exprs = exprs;\n        this.markers = markers;\n        this.empty = empty;\n    }\n    toString() { return this.empty ? \"()\" : this.exprs.map(e => maybeParens(e, this)).join(\" \"); }\n    eq(other) {\n        return exprsEq(this.exprs, other.exprs) && this.markers.every((m, i) => {\n            let om = other.markers[i];\n            return m.length == om.length && m.every((x, i) => x.eq(om[i]));\n        });\n    }\n    walk(f) {\n        let exprs = walkExprs(this.exprs, f);\n        return f(exprs == this.exprs ? this : new SequenceExpression(this.start, exprs, this.markers, this.empty && !exprs.length));\n    }\n}\nSequenceExpression.prototype.prec = 2;\nclass ConflictMarker extends Node {\n    constructor(start, id, type) {\n        super(start);\n        this.id = id;\n        this.type = type;\n    }\n    toString() { return (this.type == \"ambig\" ? \"~\" : \"!\") + this.id.name; }\n    eq(other) { return this.id.name == other.id.name && this.type == other.type; }\n}\nclass RepeatExpression extends Expression {\n    constructor(start, expr, kind) {\n        super(start);\n        this.expr = expr;\n        this.kind = kind;\n    }\n    toString() { return maybeParens(this.expr, this) + this.kind; }\n    eq(other) {\n        return exprEq(this.expr, other.expr) && this.kind == other.kind;\n    }\n    walk(f) {\n        let expr = this.expr.walk(f);\n        return f(expr == this.expr ? this : new RepeatExpression(this.start, expr, this.kind));\n    }\n}\nRepeatExpression.prototype.prec = 3;\nclass LiteralExpression extends Expression {\n    // value.length is always > 0\n    constructor(start, value) {\n        super(start);\n        this.value = value;\n    }\n    toString() { return JSON.stringify(this.value); }\n    eq(other) { return this.value == other.value; }\n}\nclass SetExpression extends Expression {\n    constructor(start, ranges, inverted) {\n        super(start);\n        this.ranges = ranges;\n        this.inverted = inverted;\n    }\n    toString() {\n        return `[${this.inverted ? \"^\" : \"\"}${this.ranges.map(([a, b]) => {\n            return String.fromCodePoint(a) + (b == a + 1 ? \"\" : \"-\" + String.fromCodePoint(b));\n        })}]`;\n    }\n    eq(other) {\n        return this.inverted == other.inverted && this.ranges.length == other.ranges.length &&\n            this.ranges.every(([a, b], i) => { let [x, y] = other.ranges[i]; return a == x && b == y; });\n    }\n}\nclass AnyExpression extends Expression {\n    constructor(start) {\n        super(start);\n    }\n    toString() { return \"_\"; }\n    eq() { return true; }\n}\nfunction walkExprs(exprs, f) {\n    let result = null;\n    for (let i = 0; i < exprs.length; i++) {\n        let expr = exprs[i].walk(f);\n        if (expr != exprs[i] && !result)\n            result = exprs.slice(0, i);\n        if (result)\n            result.push(expr);\n    }\n    return result || exprs;\n}\nconst CharClasses = {\n    asciiLetter: [[65, 91], [97, 123]],\n    asciiLowercase: [[97, 123]],\n    asciiUppercase: [[65, 91]],\n    digit: [[48, 58]],\n    whitespace: [[9, 14], [32, 33], [133, 134], [160, 161], [5760, 5761], [8192, 8203],\n        [8232, 8234], [8239, 8240], [8287, 8288], [12288, 12289]],\n    eof: [[0xffff, 0xffff]]\n};\nclass CharClass extends Expression {\n    constructor(start, type) {\n        super(start);\n        this.type = type;\n    }\n    toString() { return \"@\" + this.type; }\n    eq(expr) { return this.type == expr.type; }\n}\nfunction exprEq(a, b) {\n    return a.constructor == b.constructor && a.eq(b);\n}\nfunction exprsEq(a, b) {\n    return a.length == b.length && a.every((e, i) => exprEq(e, b[i]));\n}\nclass Prop extends Node {\n    constructor(start, at, name, value) {\n        super(start);\n        this.at = at;\n        this.name = name;\n        this.value = value;\n    }\n    eq(other) {\n        return this.name == other.name && this.value.length == other.value.length &&\n            this.value.every((v, i) => v.value == other.value[i].value && v.name == other.value[i].name);\n    }\n    toString() {\n        let result = (this.at ? \"@\" : \"\") + this.name;\n        if (this.value.length) {\n            result += \"=\";\n            for (let { name, value } of this.value)\n                result += name ? `{${name}}` : /[^\\w-]/.test(value) ? JSON.stringify(value) : value;\n        }\n        return result;\n    }\n    static eqProps(a, b) {\n        return a.length == b.length && a.every((p, i) => p.eq(b[i]));\n    }\n}\nclass PropPart extends Node {\n    constructor(start, value, name) {\n        super(start);\n        this.value = value;\n        this.name = name;\n    }\n}\nfunction maybeParens(node, parent) {\n    return node.prec < parent.prec ? \"(\" + node.toString() + \")\" : node.toString();\n}\n\n/**\nThe type of error raised when the parser generator finds an issue.\n*/\nclass GenError extends Error {\n}\n\nfunction hasProps(props) {\n    for (let _p in props)\n        return true;\n    return false;\n}\nlet termHash = 0;\nclass Term {\n    constructor(name, flags, nodeName, props = {}) {\n        this.name = name;\n        this.flags = flags;\n        this.nodeName = nodeName;\n        this.props = props;\n        this.hash = ++termHash; // Used for sorting and hashing during parser generation\n        this.id = -1; // Assigned in a later stage, used in actual output\n        // Filled in only after the rules are simplified, used in automaton.ts\n        this.rules = [];\n    }\n    toString() { return this.name; }\n    get nodeType() { return this.top || this.nodeName != null || hasProps(this.props) || this.repeated; }\n    get terminal() { return (this.flags & 1 /* TermFlag.Terminal */) > 0; }\n    get eof() { return (this.flags & 4 /* TermFlag.Eof */) > 0; }\n    get error() { return \"error\" in this.props; }\n    get top() { return (this.flags & 2 /* TermFlag.Top */) > 0; }\n    get interesting() { return this.flags > 0 || this.nodeName != null; }\n    get repeated() { return (this.flags & 16 /* TermFlag.Repeated */) > 0; }\n    set preserve(value) { this.flags = value ? this.flags | 8 /* TermFlag.Preserve */ : this.flags & ~8 /* TermFlag.Preserve */; }\n    get preserve() { return (this.flags & 8 /* TermFlag.Preserve */) > 0; }\n    set inline(value) { this.flags = value ? this.flags | 32 /* TermFlag.Inline */ : this.flags & ~32 /* TermFlag.Inline */; }\n    get inline() { return (this.flags & 32 /* TermFlag.Inline */) > 0; }\n    cmp(other) { return this.hash - other.hash; }\n}\nclass TermSet {\n    constructor() {\n        this.terms = [];\n        // Map from term names to Term instances\n        this.names = Object.create(null);\n        this.tops = [];\n        this.eof = this.term(\"\", null, 1 /* TermFlag.Terminal */ | 4 /* TermFlag.Eof */);\n        this.error = this.term(\"\", \"\", 8 /* TermFlag.Preserve */);\n    }\n    term(name, nodeName, flags = 0, props = {}) {\n        let term = new Term(name, flags, nodeName, props);\n        this.terms.push(term);\n        this.names[name] = term;\n        return term;\n    }\n    makeTop(nodeName, props) {\n        const term = this.term(\"@top\", nodeName, 2 /* TermFlag.Top */, props);\n        this.tops.push(term);\n        return term;\n    }\n    makeTerminal(name, nodeName, props = {}) {\n        return this.term(name, nodeName, 1 /* TermFlag.Terminal */, props);\n    }\n    makeNonTerminal(name, nodeName, props = {}) {\n        return this.term(name, nodeName, 0, props);\n    }\n    makeRepeat(name) {\n        return this.term(name, null, 16 /* TermFlag.Repeated */);\n    }\n    uniqueName(name) {\n        for (let i = 0;; i++) {\n            let cur = i ? `${name}-${i}` : name;\n            if (!this.names[cur])\n                return cur;\n        }\n    }\n    finish(rules) {\n        for (let rule of rules)\n            rule.name.rules.push(rule);\n        this.terms = this.terms.filter(t => t.terminal || t.preserve || rules.some(r => r.name == t || r.parts.includes(t)));\n        let names = {};\n        let nodeTypes = [this.error];\n        this.error.id = 0 /* T.Err */;\n        let nextID = 0 /* T.Err */ + 1;\n        // Assign ids to terms that represent node types\n        for (let term of this.terms)\n            if (term.id < 0 && term.nodeType && !term.repeated) {\n                term.id = nextID++;\n                nodeTypes.push(term);\n            }\n        // Put all repeated terms after the regular node types\n        let minRepeatTerm = nextID;\n        for (let term of this.terms)\n            if (term.repeated) {\n                term.id = nextID++;\n                nodeTypes.push(term);\n            }\n        // Then comes the EOF term\n        this.eof.id = nextID++;\n        // And then the remaining (non-node, non-repeat) terms.\n        for (let term of this.terms) {\n            if (term.id < 0)\n                term.id = nextID++;\n            if (term.name)\n                names[term.id] = term.name;\n        }\n        if (nextID >= 0xfffe)\n            throw new GenError(\"Too many terms\");\n        return { nodeTypes, names, minRepeatTerm, maxTerm: nextID - 1 };\n    }\n}\nfunction cmpSet(a, b, cmp) {\n    if (a.length != b.length)\n        return a.length - b.length;\n    for (let i = 0; i < a.length; i++) {\n        let diff = cmp(a[i], b[i]);\n        if (diff)\n            return diff;\n    }\n    return 0;\n}\nconst none$3 = [];\nclass Conflicts {\n    constructor(precedence, ambigGroups = none$3, cut = 0) {\n        this.precedence = precedence;\n        this.ambigGroups = ambigGroups;\n        this.cut = cut;\n    }\n    join(other) {\n        if (this == Conflicts.none || this == other)\n            return other;\n        if (other == Conflicts.none)\n            return this;\n        return new Conflicts(Math.max(this.precedence, other.precedence), union(this.ambigGroups, other.ambigGroups), Math.max(this.cut, other.cut));\n    }\n    cmp(other) {\n        return this.precedence - other.precedence || cmpSet(this.ambigGroups, other.ambigGroups, (a, b) => a < b ? -1 : a > b ? 1 : 0) ||\n            this.cut - other.cut;\n    }\n}\nConflicts.none = new Conflicts(0);\nfunction union(a, b) {\n    if (a.length == 0 || a == b)\n        return b;\n    if (b.length == 0)\n        return a;\n    let result = a.slice();\n    for (let value of b)\n        if (!a.includes(value))\n            result.push(value);\n    return result.sort();\n}\nlet ruleID = 0;\nclass Rule {\n    constructor(name, parts, conflicts, skip) {\n        this.name = name;\n        this.parts = parts;\n        this.conflicts = conflicts;\n        this.skip = skip;\n        this.id = ruleID++;\n    }\n    cmp(rule) {\n        return this.id - rule.id;\n    }\n    cmpNoName(rule) {\n        return this.parts.length - rule.parts.length ||\n            this.skip.hash - rule.skip.hash ||\n            this.parts.reduce((r, s, i) => r || s.cmp(rule.parts[i]), 0) ||\n            cmpSet(this.conflicts, rule.conflicts, (a, b) => a.cmp(b));\n    }\n    toString() {\n        return this.name + \" -> \" + this.parts.join(\" \");\n    }\n    get isRepeatWrap() {\n        return this.name.repeated && this.parts.length == 2 && this.parts[0] == this.name;\n    }\n    sameReduce(other) {\n        return this.name == other.name && this.parts.length == other.parts.length && this.isRepeatWrap == other.isRepeatWrap;\n    }\n}\n\nconst MAX_CHAR = 0xffff;\nclass Edge {\n    constructor(from, to, target) {\n        this.from = from;\n        this.to = to;\n        this.target = target;\n    }\n    toString() {\n        return `-> ${this.target.id}[label=${JSON.stringify(this.from < 0 ? \"\" : charFor(this.from) +\n            (this.to > this.from + 1 ? \"-\" + charFor(this.to - 1) : \"\"))}]`;\n    }\n}\nfunction charFor(n) {\n    return n > MAX_CHAR ? \"\"\n        : n == 10 ? \"\\\\n\"\n            : n == 13 ? \"\\\\r\"\n                : n < 32 || n >= 0xd800 && n < 0xdfff ? \"\\\\u{\" + n.toString(16) + \"}\"\n                    : String.fromCharCode(n);\n}\nfunction minimize(states, start) {\n    let partition = Object.create(null);\n    let byAccepting = Object.create(null);\n    for (let state of states) {\n        let id = ids(state.accepting);\n        let group = byAccepting[id] || (byAccepting[id] = []);\n        group.push(state);\n        partition[state.id] = group;\n    }\n    for (;;) {\n        let split = false, newPartition = Object.create(null);\n        for (let state of states) {\n            if (newPartition[state.id])\n                continue;\n            let group = partition[state.id];\n            if (group.length == 1) {\n                newPartition[group[0].id] = group;\n                continue;\n            }\n            let parts = [];\n            groups: for (let state of group) {\n                for (let p of parts) {\n                    if (isEquivalent(state, p[0], partition)) {\n                        p.push(state);\n                        continue groups;\n                    }\n                }\n                parts.push([state]);\n            }\n            if (parts.length > 1)\n                split = true;\n            for (let p of parts)\n                for (let s of p)\n                    newPartition[s.id] = p;\n        }\n        if (!split)\n            return applyMinimization(states, start, partition);\n        partition = newPartition;\n    }\n}\nfunction isEquivalent(a, b, partition) {\n    if (a.edges.length != b.edges.length)\n        return false;\n    for (let i = 0; i < a.edges.length; i++) {\n        let eA = a.edges[i], eB = b.edges[i];\n        if (eA.from != eB.from || eA.to != eB.to || partition[eA.target.id] != partition[eB.target.id])\n            return false;\n    }\n    return true;\n}\nfunction applyMinimization(states, start, partition) {\n    for (let state of states) {\n        for (let i = 0; i < state.edges.length; i++) {\n            let edge = state.edges[i], target = partition[edge.target.id][0];\n            if (target != edge.target)\n                state.edges[i] = new Edge(edge.from, edge.to, target);\n        }\n    }\n    return partition[start.id][0];\n}\nlet stateID = 1;\nlet State$1 = class State {\n    constructor(accepting = [], id = stateID++) {\n        this.accepting = accepting;\n        this.id = id;\n        this.edges = [];\n    }\n    edge(from, to, target) {\n        this.edges.push(new Edge(from, to, target));\n    }\n    nullEdge(target) { this.edge(-1, -1, target); }\n    compile() {\n        let labeled = Object.create(null), localID = 0;\n        let startState = explore(this.closure().sort((a, b) => a.id - b.id));\n        return minimize(Object.values(labeled), startState);\n        function explore(states) {\n            let newState = labeled[ids(states)] =\n                new State(states.reduce((a, s) => union(a, s.accepting), []), localID++);\n            let out = [];\n            for (let state of states)\n                for (let edge of state.edges) {\n                    if (edge.from >= 0)\n                        out.push(edge);\n                }\n            let transitions = mergeEdges(out);\n            for (let merged of transitions) {\n                let targets = merged.targets.sort((a, b) => a.id - b.id);\n                newState.edge(merged.from, merged.to, labeled[ids(targets)] || explore(targets));\n            }\n            return newState;\n        }\n    }\n    closure() {\n        let result = [], seen = Object.create(null);\n        function explore(state) {\n            if (seen[state.id])\n                return;\n            seen[state.id] = true;\n            // States with only epsilon edges and no accepting term that\n            // isn't also in the next states are left out to help reduce the\n            // number of unique state combinations\n            if (state.edges.some(e => e.from >= 0) ||\n                (state.accepting.length > 0 && !state.edges.some(e => sameSet$1(state.accepting, e.target.accepting))))\n                result.push(state);\n            for (let edge of state.edges)\n                if (edge.from < 0)\n                    explore(edge.target);\n        }\n        explore(this);\n        return result;\n    }\n    findConflicts(occurTogether) {\n        let conflicts = [], cycleTerms = this.cycleTerms();\n        function add(a, b, soft, aEdges, bEdges) {\n            if (a.id < b.id) {\n                [a, b] = [b, a];\n                soft = -soft;\n            }\n            let found = conflicts.find(c => c.a == a && c.b == b);\n            if (!found)\n                conflicts.push(new Conflict$1(a, b, soft, exampleFromEdges(aEdges), bEdges && exampleFromEdges(bEdges)));\n            else if (found.soft != soft)\n                found.soft = 0;\n        }\n        this.reachable((state, edges) => {\n            if (state.accepting.length == 0)\n                return;\n            for (let i = 0; i < state.accepting.length; i++)\n                for (let j = i + 1; j < state.accepting.length; j++)\n                    add(state.accepting[i], state.accepting[j], 0, edges);\n            state.reachable((s, es) => {\n                if (s != state)\n                    for (let term of s.accepting) {\n                        let hasCycle = cycleTerms.includes(term);\n                        for (let orig of state.accepting)\n                            if (term != orig)\n                                add(term, orig, hasCycle || cycleTerms.includes(orig) || !occurTogether(term, orig) ? 0 : 1, edges, edges.concat(es));\n                    }\n            });\n        });\n        return conflicts;\n    }\n    cycleTerms() {\n        let work = [];\n        this.reachable(state => {\n            for (let { target } of state.edges)\n                work.push(state, target);\n        });\n        let table = new Map;\n        let haveCycle = [];\n        for (let i = 0; i < work.length;) {\n            let from = work[i++], to = work[i++];\n            let entry = table.get(from);\n            if (!entry)\n                table.set(from, entry = []);\n            if (entry.includes(to))\n                continue;\n            if (from == to) {\n                if (!haveCycle.includes(from))\n                    haveCycle.push(from);\n            }\n            else {\n                for (let next of entry)\n                    work.push(from, next);\n                entry.push(to);\n            }\n        }\n        let result = [];\n        for (let state of haveCycle) {\n            for (let term of state.accepting) {\n                if (!result.includes(term))\n                    result.push(term);\n            }\n        }\n        return result;\n    }\n    reachable(f) {\n        let seen = [], edges = [];\n        (function explore(s) {\n            f(s, edges);\n            seen.push(s);\n            for (let edge of s.edges)\n                if (!seen.includes(edge.target)) {\n                    edges.push(edge);\n                    explore(edge.target);\n                    edges.pop();\n                }\n        })(this);\n    }\n    toString() {\n        let out = \"digraph {\\n\";\n        this.reachable(state => {\n            if (state.accepting.length)\n                out += `  ${state.id} [label=${JSON.stringify(state.accepting.join())}];\\n`;\n            for (let edge of state.edges)\n                out += `  ${state.id} ${edge};\\n`;\n        });\n        return out + \"}\";\n    }\n    // Tokenizer data is represented as a single flat array. This\n    // contains regions for each tokenizer state. Region offsets are\n    // used to identify states.\n    //\n    // Each state is laid out as:\n    //  - Token group mask\n    //  - Offset of the end of the accepting data\n    //  - Number of outgoing edges in the state\n    //  - Pairs of token masks and term ids that indicate the accepting\n    //    states, sorted by precedence\n    //  - Triples for the edges: each with a low and high bound and the\n    //    offset of the next state.\n    toArray(groupMasks, precedence) {\n        let offsets = []; // Used to 'link' the states after building the arrays\n        let data = [];\n        this.reachable(state => {\n            let start = data.length;\n            let acceptEnd = start + 3 + state.accepting.length * 2;\n            offsets[state.id] = start;\n            data.push(state.stateMask(groupMasks), acceptEnd, state.edges.length);\n            state.accepting.sort((a, b) => precedence.indexOf(a.id) - precedence.indexOf(b.id));\n            for (let term of state.accepting)\n                data.push(term.id, groupMasks[term.id] || 0xffff);\n            for (let edge of state.edges)\n                data.push(edge.from, edge.to, -edge.target.id - 1);\n        });\n        // Replace negative numbers with resolved state offsets\n        for (let i = 0; i < data.length; i++)\n            if (data[i] < 0)\n                data[i] = offsets[-data[i] - 1];\n        if (data.length > Math.pow(2, 16))\n            throw new GenError(\"Tokenizer tables too big to represent with 16-bit offsets.\");\n        return Uint16Array.from(data);\n    }\n    stateMask(groupMasks) {\n        let mask = 0;\n        this.reachable(state => {\n            for (let term of state.accepting)\n                mask |= (groupMasks[term.id] || 0xffff);\n        });\n        return mask;\n    }\n};\nlet Conflict$1 = class Conflict {\n    constructor(a, b, \n    // Conflicts between two non-cyclic tokens are marked as\n    // 'soft', with a negative number if a is shorter than\n    // b, and a positive if b is shorter than a.\n    soft, exampleA, exampleB) {\n        this.a = a;\n        this.b = b;\n        this.soft = soft;\n        this.exampleA = exampleA;\n        this.exampleB = exampleB;\n    }\n};\nfunction exampleFromEdges(edges) {\n    let str = \"\";\n    for (let i = 0; i < edges.length; i++)\n        str += String.fromCharCode(edges[i].from);\n    return str;\n}\nfunction ids(elts) {\n    let result = \"\";\n    for (let elt of elts) {\n        if (result.length)\n            result += \"-\";\n        result += elt.id;\n    }\n    return result;\n}\nfunction sameSet$1(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i])\n            return false;\n    return true;\n}\nclass MergedEdge {\n    constructor(from, to, targets) {\n        this.from = from;\n        this.to = to;\n        this.targets = targets;\n    }\n}\n// Merge multiple edges (tagged by character ranges) into a set of\n// mutually exclusive ranges pointing at all target states for that\n// range\nfunction mergeEdges(edges) {\n    let separate = [], result = [];\n    for (let edge of edges) {\n        if (!separate.includes(edge.from))\n            separate.push(edge.from);\n        if (!separate.includes(edge.to))\n            separate.push(edge.to);\n    }\n    separate.sort((a, b) => a - b);\n    for (let i = 1; i < separate.length; i++) {\n        let from = separate[i - 1], to = separate[i];\n        let found = [];\n        for (let edge of edges)\n            if (edge.to > from && edge.from < to) {\n                for (let target of edge.target.closure())\n                    if (!found.includes(target))\n                        found.push(target);\n            }\n        if (found.length)\n            result.push(new MergedEdge(from, to, found));\n    }\n    let eof = edges.filter(e => e.from == 65535 /* Seq.End */ && e.to == 65535 /* Seq.End */);\n    if (eof.length) {\n        let found = [];\n        for (let edge of eof)\n            for (let target of edge.target.closure())\n                if (!found.includes(target))\n                    found.push(target);\n        if (found.length)\n            result.push(new MergedEdge(65535 /* Seq.End */, 65535 /* Seq.End */, found));\n    }\n    return result;\n}\n\n// Note that this is the parser for grammar files, not the generated parser\nlet word = /[\\w_-]+/gy;\n// Some engines (specifically SpiderMonkey) have still not implemented \\p\ntry {\n    word = /[\\p{Alphabetic}\\d_-]+/ugy;\n}\ncatch (_) { }\nconst none$2 = [];\nclass Input {\n    constructor(string, fileName = null) {\n        this.string = string;\n        this.fileName = fileName;\n        this.type = \"sof\";\n        this.value = null;\n        this.start = 0;\n        this.end = 0;\n        this.next();\n    }\n    lineInfo(pos) {\n        for (let line = 1, cur = 0;;) {\n            let next = this.string.indexOf(\"\\n\", cur);\n            if (next > -1 && next < pos) {\n                ++line;\n                cur = next + 1;\n            }\n            else {\n                return { line, ch: pos - cur };\n            }\n        }\n    }\n    message(msg, pos = -1) {\n        let posInfo = this.fileName || \"\";\n        if (pos > -1) {\n            let info = this.lineInfo(pos);\n            posInfo += (posInfo ? \" \" : \"\") + info.line + \":\" + info.ch;\n        }\n        return posInfo ? msg + ` (${posInfo})` : msg;\n    }\n    raise(msg, pos = -1) {\n        throw new GenError(this.message(msg, pos));\n    }\n    match(pos, re) {\n        let match = re.exec(this.string.slice(pos));\n        return match ? pos + match[0].length : -1;\n    }\n    next() {\n        let start = this.match(this.end, /^(\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/);\n        if (start == this.string.length)\n            return this.set(\"eof\", null, start, start);\n        let next = this.string[start];\n        if (next == '\"') {\n            let end = this.match(start + 1, /^(\\\\.|[^\"\\\\])*\"/);\n            if (end == -1)\n                this.raise(\"Unterminated string literal\", start);\n            return this.set(\"string\", readString(this.string.slice(start + 1, end - 1)), start, end);\n        }\n        else if (next == \"'\") {\n            let end = this.match(start + 1, /^(\\\\.|[^'\\\\])*'/);\n            if (end == -1)\n                this.raise(\"Unterminated string literal\", start);\n            return this.set(\"string\", readString(this.string.slice(start + 1, end - 1)), start, end);\n        }\n        else if (next == \"@\") {\n            word.lastIndex = start + 1;\n            let m = word.exec(this.string);\n            if (!m)\n                return this.raise(\"@ without a name\", start);\n            return this.set(\"at\", m[0], start, start + 1 + m[0].length);\n        }\n        else if ((next == \"$\" || next == \"!\") && this.string[start + 1] == \"[\") {\n            let end = this.match(start + 2, /^(?:\\\\.|[^\\]\\\\])*\\]/);\n            if (end == -1)\n                this.raise(\"Unterminated character set\", start);\n            return this.set(\"set\", this.string.slice(start + 2, end - 1), start, end);\n        }\n        else if (/[\\[\\]()!~+*?{}<>\\.,|:$=]/.test(next)) {\n            return this.set(next, null, start, start + 1);\n        }\n        else {\n            word.lastIndex = start;\n            let m = word.exec(this.string);\n            if (!m)\n                return this.raise(\"Unexpected character \" + JSON.stringify(next), start);\n            return this.set(\"id\", m[0], start, start + m[0].length);\n        }\n    }\n    set(type, value, start, end) {\n        this.type = type;\n        this.value = value;\n        this.start = start;\n        this.end = end;\n    }\n    eat(type, value = null) {\n        if (this.type == type && (value == null || this.value === value)) {\n            this.next();\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    unexpected() {\n        return this.raise(`Unexpected token '${this.string.slice(this.start, this.end)}'`, this.start);\n    }\n    expect(type, value = null) {\n        let val = this.value;\n        if (this.type != type || !(value == null || val === value))\n            this.unexpected();\n        this.next();\n        return val;\n    }\n    parse() {\n        return parseGrammar(this);\n    }\n}\nfunction parseGrammar(input) {\n    let start = input.start;\n    let rules = [];\n    let prec = null;\n    let tokens = null;\n    let localTokens = [];\n    let mainSkip = null;\n    let scopedSkip = [];\n    let dialects = [];\n    let context = null;\n    let external = [];\n    let specialized = [];\n    let props = [];\n    let propSources = [];\n    let tops = [];\n    let sawTop = false;\n    let autoDelim = false;\n    while (input.type != \"eof\") {\n        let start = input.start;\n        if (input.eat(\"at\", \"top\")) {\n            if (input.type != \"id\")\n                input.raise(`Top rules must have a name`, input.start);\n            tops.push(parseRule(input, parseIdent(input)));\n            sawTop = true;\n        }\n        else if (input.type == \"at\" && input.value == \"tokens\") {\n            if (tokens)\n                input.raise(`Multiple @tokens declaractions`, input.start);\n            else\n                tokens = parseTokens(input);\n        }\n        else if (input.eat(\"at\", \"local\")) {\n            input.expect(\"id\", \"tokens\");\n            localTokens.push(parseLocalTokens(input, start));\n        }\n        else if (input.eat(\"at\", \"context\")) {\n            if (context)\n                input.raise(`Multiple @context declarations`, start);\n            let id = parseIdent(input);\n            input.expect(\"id\", \"from\");\n            let source = input.expect(\"string\");\n            context = new ContextDeclaration(start, id, source);\n        }\n        else if (input.eat(\"at\", \"external\")) {\n            if (input.eat(\"id\", \"tokens\"))\n                external.push(parseExternalTokens(input, start));\n            else if (input.eat(\"id\", \"prop\"))\n                props.push(parseExternalProp(input, start));\n            else if (input.eat(\"id\", \"extend\"))\n                specialized.push(parseExternalSpecialize(input, \"extend\", start));\n            else if (input.eat(\"id\", \"specialize\"))\n                specialized.push(parseExternalSpecialize(input, \"specialize\", start));\n            else if (input.eat(\"id\", \"propSource\"))\n                propSources.push(parseExternalPropSource(input, start));\n            else\n                input.unexpected();\n        }\n        else if (input.eat(\"at\", \"dialects\")) {\n            input.expect(\"{\");\n            for (let first = true; !input.eat(\"}\"); first = false) {\n                if (!first)\n                    input.eat(\",\");\n                dialects.push(parseIdent(input));\n            }\n        }\n        else if (input.type == \"at\" && input.value == \"precedence\") {\n            if (prec)\n                input.raise(`Multiple precedence declarations`, input.start);\n            prec = parsePrecedence(input);\n        }\n        else if (input.eat(\"at\", \"detectDelim\")) {\n            autoDelim = true;\n        }\n        else if (input.eat(\"at\", \"skip\")) {\n            let skip = parseBracedExpr(input);\n            if (input.type == \"{\") {\n                input.next();\n                let rules = [], topRules = [];\n                while (!input.eat(\"}\")) {\n                    if (input.eat(\"at\", \"top\")) {\n                        topRules.push(parseRule(input, parseIdent(input)));\n                        sawTop = true;\n                    }\n                    else {\n                        rules.push(parseRule(input));\n                    }\n                }\n                scopedSkip.push({ expr: skip, topRules, rules });\n            }\n            else {\n                if (mainSkip)\n                    input.raise(`Multiple top-level skip declarations`, input.start);\n                mainSkip = skip;\n            }\n        }\n        else {\n            rules.push(parseRule(input));\n        }\n    }\n    if (!sawTop)\n        return input.raise(`Missing @top declaration`);\n    return new GrammarDeclaration(start, rules, tops, tokens, localTokens, context, external, specialized, propSources, prec, mainSkip, scopedSkip, dialects, props, autoDelim);\n}\nfunction parseRule(input, named) {\n    let start = named ? named.start : input.start;\n    let id = named || parseIdent(input);\n    let props = parseProps(input);\n    let params = [];\n    if (input.eat(\"<\"))\n        while (!input.eat(\">\")) {\n            if (params.length)\n                input.expect(\",\");\n            params.push(parseIdent(input));\n        }\n    let expr = parseBracedExpr(input);\n    return new RuleDeclaration(start, id, props, params, expr);\n}\nfunction parseProps(input) {\n    if (input.type != \"[\")\n        return none$2;\n    let props = [];\n    input.expect(\"[\");\n    while (!input.eat(\"]\")) {\n        if (props.length)\n            input.expect(\",\");\n        props.push(parseProp(input));\n    }\n    return props;\n}\nfunction parseProp(input) {\n    let start = input.start, value = [], name = input.value, at = input.type == \"at\";\n    if (!input.eat(\"at\") && !input.eat(\"id\"))\n        input.unexpected();\n    if (input.eat(\"=\"))\n        for (;;) {\n            if (input.type == \"string\" || input.type == \"id\") {\n                value.push(new PropPart(input.start, input.value, null));\n                input.next();\n            }\n            else if (input.eat(\".\")) {\n                value.push(new PropPart(input.start, \".\", null));\n            }\n            else if (input.eat(\"{\")) {\n                value.push(new PropPart(input.start, null, input.expect(\"id\")));\n                input.expect(\"}\");\n            }\n            else {\n                break;\n            }\n        }\n    return new Prop(start, at, name, value);\n}\nfunction parseBracedExpr(input) {\n    input.expect(\"{\");\n    let expr = parseExprChoice(input);\n    input.expect(\"}\");\n    return expr;\n}\nconst SET_MARKER = \"\\ufdda\"; // (Invalid unicode character)\nfunction parseExprInner(input) {\n    let start = input.start;\n    if (input.eat(\"(\")) {\n        if (input.eat(\")\"))\n            return new SequenceExpression(start, none$2, [none$2, none$2]);\n        let expr = parseExprChoice(input);\n        input.expect(\")\");\n        return expr;\n    }\n    else if (input.type == \"string\") {\n        let value = input.value;\n        input.next();\n        if (value.length == 0)\n            return new SequenceExpression(start, none$2, [none$2, none$2]);\n        return new LiteralExpression(start, value);\n    }\n    else if (input.eat(\"id\", \"_\")) {\n        return new AnyExpression(start);\n    }\n    else if (input.type == \"set\") {\n        let content = input.value, invert = input.string[input.start] == \"!\";\n        let unescaped = readString(content.replace(/\\\\.|-|\"/g, (m) => {\n            return m == \"-\" ? SET_MARKER : m == '\"' ? '\\\\\"' : m;\n        }));\n        let ranges = [];\n        for (let pos = 0; pos < unescaped.length;) {\n            let code = unescaped.codePointAt(pos);\n            pos += code > 0xffff ? 2 : 1;\n            if (pos < unescaped.length - 1 && unescaped[pos] == SET_MARKER) {\n                let end = unescaped.codePointAt(pos + 1);\n                pos += end > 0xffff ? 3 : 2;\n                if (end < code)\n                    input.raise(\"Invalid character range\", input.start);\n                addRange(input, ranges, code, end + 1);\n            }\n            else {\n                if (code == SET_MARKER.charCodeAt(0))\n                    code = 45;\n                addRange(input, ranges, code, code + 1);\n            }\n        }\n        input.next();\n        return new SetExpression(start, ranges.sort((a, b) => a[0] - b[0]), invert);\n    }\n    else if (input.type == \"at\" && (input.value == \"specialize\" || input.value == \"extend\")) {\n        let { start, value } = input;\n        input.next();\n        let props = parseProps(input);\n        input.expect(\"<\");\n        let token = parseExprChoice(input), content;\n        if (input.eat(\",\")) {\n            content = parseExprChoice(input);\n        }\n        else if (token instanceof LiteralExpression) {\n            content = token;\n        }\n        else {\n            input.raise(`@${value} requires two arguments when its first argument isn't a literal string`);\n        }\n        input.expect(\">\");\n        return new SpecializeExpression(start, value, props, token, content);\n    }\n    else if (input.type == \"at\" && CharClasses.hasOwnProperty(input.value)) {\n        let cls = new CharClass(input.start, input.value);\n        input.next();\n        return cls;\n    }\n    else if (input.type == \"[\") {\n        let rule = parseRule(input, new Identifier(start, \"_anon\"));\n        if (rule.params.length)\n            input.raise(`Inline rules can't have parameters`, rule.start);\n        return new InlineRuleExpression(start, rule);\n    }\n    else {\n        let id = parseIdent(input);\n        if (input.type == \"[\" || input.type == \"{\") {\n            let rule = parseRule(input, id);\n            if (rule.params.length)\n                input.raise(`Inline rules can't have parameters`, rule.start);\n            return new InlineRuleExpression(start, rule);\n        }\n        else {\n            if (input.eat(\".\") && id.name == \"std\" && CharClasses.hasOwnProperty(input.value)) {\n                let cls = new CharClass(start, input.value);\n                input.next();\n                return cls;\n            }\n            return new NameExpression(start, id, parseArgs(input));\n        }\n    }\n}\nfunction parseArgs(input) {\n    let args = [];\n    if (input.eat(\"<\"))\n        while (!input.eat(\">\")) {\n            if (args.length)\n                input.expect(\",\");\n            args.push(parseExprChoice(input));\n        }\n    return args;\n}\nfunction addRange(input, ranges, from, to) {\n    if (!ranges.every(([a, b]) => b <= from || a >= to))\n        input.raise(\"Overlapping character range\", input.start);\n    ranges.push([from, to]);\n}\nfunction parseExprSuffix(input) {\n    let start = input.start;\n    let expr = parseExprInner(input);\n    for (;;) {\n        let kind = input.type;\n        if (input.eat(\"*\") || input.eat(\"?\") || input.eat(\"+\"))\n            expr = new RepeatExpression(start, expr, kind);\n        else\n            return expr;\n    }\n}\nfunction endOfSequence(input) {\n    return input.type == \"}\" || input.type == \")\" || input.type == \"|\" || input.type == \"/\" ||\n        input.type == \"/\\\\\" || input.type == \"{\" || input.type == \",\" || input.type == \">\";\n}\nfunction parseExprSequence(input) {\n    let start = input.start, exprs = [], markers = [none$2];\n    do {\n        // Add markers at this position\n        for (;;) {\n            let localStart = input.start, markerType;\n            if (input.eat(\"~\"))\n                markerType = \"ambig\";\n            else if (input.eat(\"!\"))\n                markerType = \"prec\";\n            else\n                break;\n            markers[markers.length - 1] =\n                markers[markers.length - 1].concat(new ConflictMarker(localStart, parseIdent(input), markerType));\n        }\n        if (endOfSequence(input))\n            break;\n        exprs.push(parseExprSuffix(input));\n        markers.push(none$2);\n    } while (!endOfSequence(input));\n    if (exprs.length == 1 && markers.every(ms => ms.length == 0))\n        return exprs[0];\n    return new SequenceExpression(start, exprs, markers, !exprs.length);\n}\nfunction parseExprChoice(input) {\n    let start = input.start, left = parseExprSequence(input);\n    if (!input.eat(\"|\"))\n        return left;\n    let exprs = [left];\n    do {\n        exprs.push(parseExprSequence(input));\n    } while (input.eat(\"|\"));\n    let empty = exprs.find(s => s instanceof SequenceExpression && s.empty);\n    if (empty)\n        input.raise(\"Empty expression in choice operator. If this is intentional, use () to make it explicit.\", empty.start);\n    return new ChoiceExpression(start, exprs);\n}\nfunction parseIdent(input) {\n    if (input.type != \"id\")\n        input.unexpected();\n    let start = input.start, name = input.value;\n    input.next();\n    return new Identifier(start, name);\n}\nfunction parsePrecedence(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let items = [];\n    while (!input.eat(\"}\")) {\n        if (items.length)\n            input.eat(\",\");\n        items.push({\n            id: parseIdent(input),\n            type: input.eat(\"at\", \"left\") ? \"left\" : input.eat(\"at\", \"right\") ? \"right\" : input.eat(\"at\", \"cut\") ? \"cut\" : null\n        });\n    }\n    return new PrecDeclaration(start, items);\n}\nfunction parseTokens(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let tokenRules = [];\n    let literals = [];\n    let precedences = [];\n    let conflicts = [];\n    while (!input.eat(\"}\")) {\n        if (input.type == \"at\" && input.value == \"precedence\") {\n            precedences.push(parseTokenPrecedence(input));\n        }\n        else if (input.type == \"at\" && input.value == \"conflict\") {\n            conflicts.push(parseTokenConflict(input));\n        }\n        else if (input.type == \"string\") {\n            literals.push(new LiteralDeclaration(input.start, input.expect(\"string\"), parseProps(input)));\n        }\n        else {\n            tokenRules.push(parseRule(input));\n        }\n    }\n    return new TokenDeclaration(start, precedences, conflicts, tokenRules, literals);\n}\nfunction parseLocalTokens(input, start) {\n    input.expect(\"{\");\n    let tokenRules = [];\n    let precedences = [];\n    let fallback = null;\n    while (!input.eat(\"}\")) {\n        if (input.type == \"at\" && input.value == \"precedence\") {\n            precedences.push(parseTokenPrecedence(input));\n        }\n        else if (input.eat(\"at\", \"else\") && !fallback) {\n            fallback = { id: parseIdent(input), props: parseProps(input) };\n        }\n        else {\n            tokenRules.push(parseRule(input));\n        }\n    }\n    return new LocalTokenDeclaration(start, precedences, tokenRules, fallback);\n}\nfunction parseTokenPrecedence(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let tokens = [];\n    while (!input.eat(\"}\")) {\n        if (tokens.length)\n            input.eat(\",\");\n        let expr = parseExprInner(input);\n        if (expr instanceof LiteralExpression || expr instanceof NameExpression)\n            tokens.push(expr);\n        else\n            input.raise(`Invalid expression in token precedences`, expr.start);\n    }\n    return new TokenPrecDeclaration(start, tokens);\n}\nfunction parseTokenConflict(input) {\n    let start = input.start;\n    input.next();\n    input.expect(\"{\");\n    let a = parseExprInner(input);\n    if (!(a instanceof LiteralExpression || a instanceof NameExpression))\n        input.raise(`Invalid expression in token conflict`, a.start);\n    input.eat(\",\");\n    let b = parseExprInner(input);\n    if (!(b instanceof LiteralExpression || b instanceof NameExpression))\n        input.raise(`Invalid expression in token conflict`, b.start);\n    input.expect(\"}\");\n    return new TokenConflictDeclaration(start, a, b);\n}\nfunction parseExternalTokenSet(input) {\n    let tokens = [];\n    input.expect(\"{\");\n    while (!input.eat(\"}\")) {\n        if (tokens.length)\n            input.eat(\",\");\n        let id = parseIdent(input);\n        let props = parseProps(input);\n        tokens.push({ id, props });\n    }\n    return tokens;\n}\nfunction parseExternalTokens(input, start) {\n    let id = parseIdent(input);\n    input.expect(\"id\", \"from\");\n    let from = input.expect(\"string\");\n    return new ExternalTokenDeclaration(start, id, from, parseExternalTokenSet(input));\n}\nfunction parseExternalSpecialize(input, type, start) {\n    let token = parseBracedExpr(input);\n    let id = parseIdent(input);\n    input.expect(\"id\", \"from\");\n    let from = input.expect(\"string\");\n    return new ExternalSpecializeDeclaration(start, type, token, id, from, parseExternalTokenSet(input));\n}\nfunction parseExternalPropSource(input, start) {\n    let id = parseIdent(input);\n    input.expect(\"id\", \"from\");\n    return new ExternalPropSourceDeclaration(start, id, input.expect(\"string\"));\n}\nfunction parseExternalProp(input, start) {\n    let externalID = parseIdent(input);\n    let id = input.eat(\"id\", \"as\") ? parseIdent(input) : externalID;\n    input.expect(\"id\", \"from\");\n    let from = input.expect(\"string\");\n    return new ExternalPropDeclaration(start, id, externalID, from);\n}\nfunction readString(string) {\n    let point = /\\\\(?:u\\{([\\da-f]+)\\}|u([\\da-f]{4})|x([\\da-f]{2})|([ntbrf0])|(.))|[^]/yig;\n    let out = \"\", m;\n    while (m = point.exec(string)) {\n        let [all, u1, u2, u3, single, unknown] = m;\n        if (u1 || u2 || u3)\n            out += String.fromCodePoint(parseInt(u1 || u2 || u3, 16));\n        else if (single)\n            out += single == \"n\" ? \"\\n\" : single == \"t\" ? \"\\t\" : single == \"0\" ? \"\\0\" : single == \"r\" ? \"\\r\" : single == \"f\" ? \"\\f\" : \"\\b\";\n        else if (unknown)\n            out += unknown;\n        else\n            out += all;\n    }\n    return out;\n}\n\nfunction hash(a, b) { return (a << 5) + a + b; }\nfunction hashString(h, s) {\n    for (let i = 0; i < s.length; i++)\n        h = hash(h, s.charCodeAt(i));\n    return h;\n}\n\nconst verbose = (typeof process != \"undefined\" && process.env.LOG) || \"\";\nconst timing = /\\btime\\b/.test(verbose);\nconst time = timing ? (label, f) => {\n    let t0 = Date.now();\n    let result = f();\n    console.log(`${label} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);\n    return result;\n} : (_label, f) => f();\n\nclass Pos {\n    constructor(rule, pos, \n    // NOTE `ahead` and `ambigAhead` aren't mutated anymore after `finish()` has been called\n    ahead, ambigAhead, skipAhead, via) {\n        this.rule = rule;\n        this.pos = pos;\n        this.ahead = ahead;\n        this.ambigAhead = ambigAhead;\n        this.skipAhead = skipAhead;\n        this.via = via;\n        this.hash = 0;\n    }\n    finish() {\n        let h = hash(hash(this.rule.id, this.pos), this.skipAhead.hash);\n        for (let a of this.ahead)\n            h = hash(h, a.hash);\n        for (let group of this.ambigAhead)\n            h = hashString(h, group);\n        this.hash = h;\n        return this;\n    }\n    get next() {\n        return this.pos < this.rule.parts.length ? this.rule.parts[this.pos] : null;\n    }\n    advance() {\n        return new Pos(this.rule, this.pos + 1, this.ahead, this.ambigAhead, this.skipAhead, this.via).finish();\n    }\n    get skip() {\n        return this.pos == this.rule.parts.length ? this.skipAhead : this.rule.skip;\n    }\n    cmp(pos) {\n        return this.rule.cmp(pos.rule) || this.pos - pos.pos || this.skipAhead.hash - pos.skipAhead.hash ||\n            cmpSet(this.ahead, pos.ahead, (a, b) => a.cmp(b)) || cmpSet(this.ambigAhead, pos.ambigAhead, cmpStr);\n    }\n    eqSimple(pos) {\n        return pos.rule == this.rule && pos.pos == this.pos;\n    }\n    toString() {\n        let parts = this.rule.parts.map(t => t.name);\n        parts.splice(this.pos, 0, \"\");\n        return `${this.rule.name} -> ${parts.join(\" \")}`;\n    }\n    eq(other) {\n        return this == other ||\n            this.hash == other.hash && this.rule == other.rule && this.pos == other.pos && this.skipAhead == other.skipAhead &&\n                sameSet(this.ahead, other.ahead) &&\n                sameSet(this.ambigAhead, other.ambigAhead);\n    }\n    trail(maxLen = 60) {\n        let result = [];\n        for (let pos = this; pos; pos = pos.via) {\n            for (let i = pos.pos - 1; i >= 0; i--)\n                result.push(pos.rule.parts[i]);\n        }\n        let value = result.reverse().join(\" \");\n        if (value.length > maxLen)\n            value = value.slice(value.length - maxLen).replace(/.*? /, \" \");\n        return value;\n    }\n    conflicts(pos = this.pos) {\n        let result = this.rule.conflicts[pos];\n        if (pos == this.rule.parts.length && this.ambigAhead.length)\n            result = result.join(new Conflicts(0, this.ambigAhead));\n        return result;\n    }\n    static addOrigins(group, context) {\n        let result = group.slice();\n        for (let i = 0; i < result.length; i++) {\n            let next = result[i];\n            if (next.pos == 0)\n                for (let pos of context) {\n                    if (pos.next == next.rule.name && !result.includes(pos))\n                        result.push(pos);\n                }\n        }\n        return result;\n    }\n}\nfunction conflictsAt(group) {\n    let result = Conflicts.none;\n    for (let pos of group)\n        result = result.join(pos.conflicts());\n    return result;\n}\n// Applies automatic action precedence based on repeat productions.\n// These are left-associative, so reducing the `R -> R R` rule has\n// higher precedence.\nfunction compareRepeatPrec(a, b) {\n    for (let pos of a)\n        if (pos.rule.name.repeated) {\n            for (let posB of b)\n                if (posB.rule.name == pos.rule.name) {\n                    if (pos.rule.isRepeatWrap && pos.pos == 2)\n                        return 1;\n                    if (posB.rule.isRepeatWrap && posB.pos == 2)\n                        return -1;\n                }\n        }\n    return 0;\n}\nfunction cmpStr(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\nfunction termsAhead(rule, pos, after, first) {\n    let found = [];\n    for (let i = pos + 1; i < rule.parts.length; i++) {\n        let next = rule.parts[i], cont = false;\n        if (next.terminal) {\n            addTo(next, found);\n        }\n        else\n            for (let term of first[next.name]) {\n                if (term == null)\n                    cont = true;\n                else\n                    addTo(term, found);\n            }\n        if (!cont)\n            return found;\n    }\n    for (let a of after)\n        addTo(a, found);\n    return found;\n}\nfunction eqSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction sameSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i])\n            return false;\n    return true;\n}\nclass Shift {\n    constructor(term, target) {\n        this.term = term;\n        this.target = target;\n    }\n    eq(other) { return other instanceof Shift && this.term == other.term && other.target.id == this.target.id; }\n    cmp(other) { return other instanceof Reduce ? -1 : this.term.id - other.term.id || this.target.id - other.target.id; }\n    matches(other, mapping) {\n        return other instanceof Shift && mapping[other.target.id] == mapping[this.target.id];\n    }\n    toString() { return \"s\" + this.target.id; }\n    map(mapping, states) {\n        let mapped = states[mapping[this.target.id]];\n        return mapped == this.target ? this : new Shift(this.term, mapped);\n    }\n}\nclass Reduce {\n    constructor(term, rule) {\n        this.term = term;\n        this.rule = rule;\n    }\n    eq(other) {\n        return other instanceof Reduce && this.term == other.term && other.rule.sameReduce(this.rule);\n    }\n    cmp(other) {\n        return other instanceof Shift ? 1 : this.term.id - other.term.id || this.rule.name.id - other.rule.name.id ||\n            this.rule.parts.length - other.rule.parts.length;\n    }\n    matches(other, mapping) {\n        return other instanceof Reduce && other.rule.sameReduce(this.rule);\n    }\n    toString() { return `${this.rule.name.name}(${this.rule.parts.length})`; }\n    map() { return this; }\n}\nfunction hashPositions(set) {\n    let h = 5381;\n    for (let pos of set)\n        h = hash(h, pos.hash);\n    return h;\n}\nclass ConflictContext {\n    constructor(first) {\n        this.first = first;\n        this.conflicts = [];\n    }\n}\nclass State {\n    constructor(id, set, flags = 0, skip, hash = hashPositions(set), startRule = null) {\n        this.id = id;\n        this.set = set;\n        this.flags = flags;\n        this.skip = skip;\n        this.hash = hash;\n        this.startRule = startRule;\n        this.actions = [];\n        this.actionPositions = [];\n        this.goto = [];\n        this.tokenGroup = -1;\n        this.defaultReduce = null;\n        this._actionsByTerm = null;\n    }\n    toString() {\n        let actions = this.actions.map(t => t.term + \"=\" + t).join(\",\") +\n            (this.goto.length ? \" | \" + this.goto.map(g => g.term + \"=\" + g).join(\",\") : \"\");\n        return this.id + \": \" + this.set.filter(p => p.pos > 0).join() +\n            (this.defaultReduce ? `\\n  always ${this.defaultReduce.name}(${this.defaultReduce.parts.length})`\n                : actions.length ? \"\\n  \" + actions : \"\");\n    }\n    addActionInner(value, positions) {\n        check: for (let i = 0; i < this.actions.length; i++) {\n            let action = this.actions[i];\n            if (action.term == value.term) {\n                if (action.eq(value))\n                    return null;\n                let fullPos = Pos.addOrigins(positions, this.set), actionFullPos = Pos.addOrigins(this.actionPositions[i], this.set);\n                let conflicts = conflictsAt(fullPos), actionConflicts = conflictsAt(actionFullPos);\n                let diff = compareRepeatPrec(fullPos, actionFullPos) || conflicts.precedence - actionConflicts.precedence;\n                if (diff > 0) { // Drop the existing action\n                    this.actions.splice(i, 1);\n                    this.actionPositions.splice(i, 1);\n                    i--;\n                    continue check;\n                }\n                else if (diff < 0) { // Drop this one\n                    return null;\n                }\n                else if (conflicts.ambigGroups.some(g => actionConflicts.ambigGroups.includes(g))) { // Explicitly allowed ambiguity\n                    continue check;\n                }\n                else { // Not resolved\n                    return action;\n                }\n            }\n        }\n        this.actions.push(value);\n        this.actionPositions.push(positions);\n        return null;\n    }\n    addAction(value, positions, context) {\n        let conflict = this.addActionInner(value, positions);\n        if (conflict) {\n            let conflictPos = this.actionPositions[this.actions.indexOf(conflict)][0];\n            let rules = [positions[0].rule.name, conflictPos.rule.name];\n            if (context.conflicts.some(c => c.rules.some(r => rules.includes(r))))\n                return;\n            let error;\n            if (conflict instanceof Shift)\n                error = `shift/reduce conflict between\\n  ${conflictPos}\\nand\\n  ${positions[0].rule}`;\n            else\n                error = `reduce/reduce conflict between\\n  ${conflictPos.rule}\\nand\\n  ${positions[0].rule}`;\n            error += `\\nWith input:\\n  ${positions[0].trail(70)}  ${value.term} `;\n            if (conflict instanceof Shift)\n                error += findConflictShiftSource(positions[0], conflict.term, context.first);\n            error += findConflictOrigin(conflictPos, positions[0]);\n            context.conflicts.push(new Conflict(error, rules));\n        }\n    }\n    getGoto(term) {\n        return this.goto.find(a => a.term == term);\n    }\n    hasSet(set) {\n        return eqSet(this.set, set);\n    }\n    actionsByTerm() {\n        let result = this._actionsByTerm;\n        if (!result) {\n            this._actionsByTerm = result = Object.create(null);\n            for (let action of this.actions)\n                (result[action.term.id] || (result[action.term.id] = [])).push(action);\n        }\n        return result;\n    }\n    finish() {\n        if (this.actions.length) {\n            let first = this.actions[0];\n            if (first instanceof Reduce) {\n                let { rule } = first;\n                if (this.actions.every(a => a instanceof Reduce && a.rule.sameReduce(rule)))\n                    this.defaultReduce = rule;\n            }\n        }\n        this.actions.sort((a, b) => a.cmp(b));\n        this.goto.sort((a, b) => a.cmp(b));\n    }\n    eq(other) {\n        let dThis = this.defaultReduce, dOther = other.defaultReduce;\n        if (dThis || dOther)\n            return dThis && dOther ? dThis.sameReduce(dOther) : false;\n        return this.skip == other.skip &&\n            this.tokenGroup == other.tokenGroup &&\n            eqSet(this.actions, other.actions) &&\n            eqSet(this.goto, other.goto);\n    }\n}\nfunction closure(set, first) {\n    let added = [], redo = [];\n    function addFor(name, ahead, ambigAhead, skipAhead, via) {\n        for (let rule of name.rules) {\n            let add = added.find(a => a.rule == rule);\n            if (!add) {\n                let existing = set.find(p => p.pos == 0 && p.rule == rule);\n                add = existing ? new Pos(rule, 0, existing.ahead.slice(), existing.ambigAhead, existing.skipAhead, existing.via)\n                    : new Pos(rule, 0, [], none$1, skipAhead, via);\n                added.push(add);\n            }\n            if (add.skipAhead != skipAhead)\n                throw new GenError(\"Inconsistent skip sets after \" + via.trail());\n            add.ambigAhead = union(add.ambigAhead, ambigAhead);\n            for (let term of ahead)\n                if (!add.ahead.includes(term)) {\n                    add.ahead.push(term);\n                    if (add.rule.parts.length && !add.rule.parts[0].terminal)\n                        addTo(add, redo);\n                }\n        }\n    }\n    for (let pos of set) {\n        let next = pos.next;\n        if (next && !next.terminal)\n            addFor(next, termsAhead(pos.rule, pos.pos, pos.ahead, first), pos.conflicts(pos.pos + 1).ambigGroups, pos.pos == pos.rule.parts.length - 1 ? pos.skipAhead : pos.rule.skip, pos);\n    }\n    while (redo.length) {\n        let add = redo.pop();\n        addFor(add.rule.parts[0], termsAhead(add.rule, 0, add.ahead, first), union(add.rule.conflicts[1].ambigGroups, add.rule.parts.length == 1 ? add.ambigAhead : none$1), add.rule.parts.length == 1 ? add.skipAhead : add.rule.skip, add);\n    }\n    let result = set.slice();\n    for (let add of added) {\n        add.ahead.sort((a, b) => a.hash - b.hash);\n        add.finish();\n        let origIndex = set.findIndex(p => p.pos == 0 && p.rule == add.rule);\n        if (origIndex > -1)\n            result[origIndex] = add;\n        else\n            result.push(add);\n    }\n    return result.sort((a, b) => a.cmp(b));\n}\nfunction addTo(value, array) {\n    if (!array.includes(value))\n        array.push(value);\n}\nfunction computeFirstSets(terms) {\n    let table = Object.create(null);\n    for (let t of terms.terms)\n        if (!t.terminal)\n            table[t.name] = [];\n    for (;;) {\n        let change = false;\n        for (let nt of terms.terms)\n            if (!nt.terminal)\n                for (let rule of nt.rules) {\n                    let set = table[nt.name];\n                    let found = false, startLen = set.length;\n                    for (let part of rule.parts) {\n                        found = true;\n                        if (part.terminal) {\n                            addTo(part, set);\n                        }\n                        else {\n                            for (let t of table[part.name]) {\n                                if (t == null)\n                                    found = false;\n                                else\n                                    addTo(t, set);\n                            }\n                        }\n                        if (found)\n                            break;\n                    }\n                    if (!found)\n                        addTo(null, set);\n                    if (set.length > startLen)\n                        change = true;\n                }\n        if (!change)\n            return table;\n    }\n}\nclass Core {\n    constructor(set, state) {\n        this.set = set;\n        this.state = state;\n    }\n}\nclass Conflict {\n    constructor(error, rules) {\n        this.error = error;\n        this.rules = rules;\n    }\n}\nfunction findConflictOrigin(a, b) {\n    if (a.eqSimple(b))\n        return \"\";\n    function via(root, start) {\n        let hist = [];\n        for (let p = start.via; !p.eqSimple(root); p = p.via)\n            hist.push(p);\n        if (!hist.length)\n            return \"\";\n        hist.unshift(start);\n        return hist.reverse().map((p, i) => \"\\n\" + \"  \".repeat(i + 1) + (p == start ? \"\" : \"via \") + p).join(\"\");\n    }\n    for (let p = a; p; p = p.via)\n        for (let p2 = b; p2; p2 = p2.via) {\n            if (p.eqSimple(p2))\n                return \"\\nShared origin: \" + p + via(p, a) + via(p, b);\n        }\n    return \"\";\n}\n// Search for the reason that a given 'after' token exists at the\n// given pos, by scanning up the trail of positions. Because the `via`\n// link is only one source of a pos, of potentially many, this\n// requires a re-simulation of the whole path up to the pos.\nfunction findConflictShiftSource(conflictPos, termAfter, first) {\n    let pos = conflictPos, path = [];\n    for (;;) {\n        for (let i = pos.pos - 1; i >= 0; i--)\n            path.push(pos.rule.parts[i]);\n        if (!pos.via)\n            break;\n        pos = pos.via;\n    }\n    path.reverse();\n    let seen = new Set();\n    function explore(pos, i, hasMatch) {\n        if (i == path.length && hasMatch && !pos.next)\n            return `\\nThe reduction of ${conflictPos.rule.name} is allowed before ${termAfter} because of this rule:\\n  ${hasMatch}`;\n        for (let next; next = pos.next;) {\n            if (i < path.length && next == path[i]) {\n                let inner = explore(pos.advance(), i + 1, hasMatch);\n                if (inner)\n                    return inner;\n            }\n            let after = pos.rule.parts[pos.pos + 1], match = pos.pos + 1 == pos.rule.parts.length ? hasMatch : null;\n            if (after && (after.terminal ? after == termAfter : first[after.name].includes(termAfter)))\n                match = pos.advance();\n            for (let rule of next.rules) {\n                let hash = (rule.id << 5) + i + (match ? 555 : 0);\n                if (!seen.has(hash)) {\n                    seen.add(hash);\n                    let inner = explore(new Pos(rule, 0, [], [], next, pos), i, match);\n                    if (inner)\n                        return inner;\n                }\n            }\n            if (!next.terminal && first[next.name].includes(null))\n                pos = pos.advance();\n            else\n                break;\n        }\n        return \"\";\n    }\n    return explore(pos, 0, null);\n}\n// Builds a full LR(1) automaton\nfunction buildFullAutomaton(terms, startTerms, first) {\n    let states = [], statesBySetHash = {};\n    let cores = {};\n    let t0 = Date.now();\n    function getState(core, top) {\n        if (core.length == 0)\n            return null;\n        let coreHash = hashPositions(core), byHash = cores[coreHash];\n        let skip;\n        for (let pos of core) {\n            if (!skip)\n                skip = pos.skip;\n            else if (skip != pos.skip)\n                throw new GenError(\"Inconsistent skip sets after \" + pos.trail());\n        }\n        if (byHash)\n            for (let known of byHash)\n                if (eqSet(core, known.set)) {\n                    if (known.state.skip != skip)\n                        throw new GenError(\"Inconsistent skip sets after \" + known.set[0].trail());\n                    return known.state;\n                }\n        let set = closure(core, first);\n        let hash = hashPositions(set), forHash = statesBySetHash[hash] || (statesBySetHash[hash] = []);\n        let found;\n        if (!top)\n            for (let state of forHash)\n                if (state.hasSet(set))\n                    found = state;\n        if (!found) {\n            found = new State(states.length, set, 0, skip, hash, top);\n            forHash.push(found);\n            states.push(found);\n            if (timing && states.length % 500 == 0)\n                console.log(`${states.length} states after ${((Date.now() - t0) / 1000).toFixed(2)}s`);\n        }\n        (cores[coreHash] || (cores[coreHash] = [])).push(new Core(core, found));\n        return found;\n    }\n    for (const startTerm of startTerms) {\n        const startSkip = startTerm.rules.length ? startTerm.rules[0].skip : terms.names[\"%noskip\"];\n        getState(startTerm.rules.map(rule => new Pos(rule, 0, [terms.eof], none$1, startSkip, null).finish()), startTerm);\n    }\n    let conflicts = new ConflictContext(first);\n    for (let filled = 0; filled < states.length; filled++) {\n        let state = states[filled];\n        let byTerm = [], byTermPos = [], atEnd = [];\n        for (let pos of state.set) {\n            if (pos.pos == pos.rule.parts.length) {\n                if (!pos.rule.name.top)\n                    atEnd.push(pos);\n            }\n            else {\n                let next = pos.rule.parts[pos.pos];\n                let index = byTerm.indexOf(next);\n                if (index < 0) {\n                    byTerm.push(next);\n                    byTermPos.push([pos]);\n                }\n                else {\n                    byTermPos[index].push(pos);\n                }\n            }\n        }\n        for (let i = 0; i < byTerm.length; i++) {\n            let term = byTerm[i], positions = byTermPos[i].map(p => p.advance());\n            if (term.terminal) {\n                let set = applyCut(positions);\n                let next = getState(set);\n                if (next)\n                    state.addAction(new Shift(term, next), byTermPos[i], conflicts);\n            }\n            else {\n                let goto = getState(positions);\n                if (goto)\n                    state.goto.push(new Shift(term, goto));\n            }\n        }\n        let replaced = false;\n        for (let pos of atEnd)\n            for (let ahead of pos.ahead) {\n                let count = state.actions.length;\n                state.addAction(new Reduce(ahead, pos.rule), [pos], conflicts);\n                if (state.actions.length == count)\n                    replaced = true;\n            }\n        // If some actions were replaced by others, double-check whether\n        // goto entries are now superfluous (for example, in an operator\n        // precedence-related state that has a shift for `*` but only a\n        // reduce for `+`, we don't need a goto entry for rules that start\n        // with `+`)\n        if (replaced)\n            for (let i = 0; i < state.goto.length; i++) {\n                let start = first[state.goto[i].term.name];\n                if (!start.some(term => state.actions.some(a => a.term == term && (a instanceof Shift))))\n                    state.goto.splice(i--, 1);\n            }\n    }\n    if (conflicts.conflicts.length)\n        throw new GenError(conflicts.conflicts.map(c => c.error).join(\"\\n\\n\"));\n    // Resolve alwaysReduce and sort actions\n    for (let state of states)\n        state.finish();\n    if (timing)\n        console.log(`${states.length} states total.`);\n    return states;\n}\nfunction applyCut(set) {\n    let found = null, cut = 1;\n    for (let pos of set) {\n        let value = pos.rule.conflicts[pos.pos - 1].cut;\n        if (value < cut)\n            continue;\n        if (!found || value > cut) {\n            cut = value;\n            found = [];\n        }\n        found.push(pos);\n    }\n    return found || set;\n}\n// Verify that there are no conflicting actions or goto entries in the\n// two given states (using the state ID remapping provided in mapping)\nfunction canMerge(a, b, mapping) {\n    // If a goto for the same term differs, that makes the states\n    // incompatible\n    for (let goto of a.goto)\n        for (let other of b.goto) {\n            if (goto.term == other.term && mapping[goto.target.id] != mapping[other.target.id])\n                return false;\n        }\n    // If there is an action where a conflicting action exists in the\n    // other state, the merge is only allowed when both states have the\n    // exact same set of actions for this term.\n    let byTerm = b.actionsByTerm();\n    for (let action of a.actions) {\n        let setB = byTerm[action.term.id];\n        if (setB && setB.some(other => !other.matches(action, mapping))) {\n            if (setB.length == 1)\n                return false;\n            let setA = a.actionsByTerm()[action.term.id];\n            if (setA.length != setB.length || setA.some(a1 => !setB.some(a2 => a1.matches(a2, mapping))))\n                return false;\n        }\n    }\n    return true;\n}\nfunction mergeStates(states, mapping) {\n    let newStates = [];\n    for (let state of states) {\n        let newID = mapping[state.id];\n        if (!newStates[newID]) {\n            newStates[newID] = new State(newID, state.set, 0, state.skip, state.hash, state.startRule);\n            newStates[newID].tokenGroup = state.tokenGroup;\n            newStates[newID].defaultReduce = state.defaultReduce;\n        }\n    }\n    for (let state of states) {\n        let newID = mapping[state.id], target = newStates[newID];\n        target.flags |= state.flags;\n        for (let i = 0; i < state.actions.length; i++) {\n            let action = state.actions[i].map(mapping, newStates);\n            if (!target.actions.some(a => a.eq(action))) {\n                target.actions.push(action);\n                target.actionPositions.push(state.actionPositions[i]);\n            }\n        }\n        for (let goto of state.goto) {\n            let mapped = goto.map(mapping, newStates);\n            if (!target.goto.some(g => g.eq(mapped)))\n                target.goto.push(mapped);\n        }\n    }\n    return newStates;\n}\nclass Group {\n    constructor(origin, member) {\n        this.origin = origin;\n        this.members = [member];\n    }\n}\nfunction samePosSet(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].eqSimple(b[i]))\n            return false;\n    return true;\n}\n// Collapse an LR(1) automaton to an LALR-like automaton\nfunction collapseAutomaton(states) {\n    let mapping = [], groups = [];\n    assignGroups: for (let i = 0; i < states.length; i++) {\n        let state = states[i];\n        if (!state.startRule)\n            for (let j = 0; j < groups.length; j++) {\n                let group = groups[j], other = states[group.members[0]];\n                if (state.tokenGroup == other.tokenGroup &&\n                    state.skip == other.skip &&\n                    !other.startRule &&\n                    samePosSet(state.set, other.set)) {\n                    group.members.push(i);\n                    mapping.push(j);\n                    continue assignGroups;\n                }\n            }\n        mapping.push(groups.length);\n        groups.push(new Group(groups.length, i));\n    }\n    function spill(groupIndex, index) {\n        let group = groups[groupIndex], state = states[group.members[index]];\n        let pop = group.members.pop();\n        if (index != group.members.length)\n            group.members[index] = pop;\n        for (let i = groupIndex + 1; i < groups.length; i++) {\n            mapping[state.id] = i;\n            if (groups[i].origin == group.origin &&\n                groups[i].members.every(id => canMerge(state, states[id], mapping))) {\n                groups[i].members.push(state.id);\n                return;\n            }\n        }\n        mapping[state.id] = groups.length;\n        groups.push(new Group(group.origin, state.id));\n    }\n    for (let pass = 1;; pass++) {\n        let conflicts = false, t0 = Date.now();\n        for (let g = 0, startLen = groups.length; g < startLen; g++) {\n            let group = groups[g];\n            for (let i = 0; i < group.members.length - 1; i++) {\n                for (let j = i + 1; j < group.members.length; j++) {\n                    let idA = group.members[i], idB = group.members[j];\n                    if (!canMerge(states[idA], states[idB], mapping)) {\n                        conflicts = true;\n                        spill(g, j--);\n                    }\n                }\n            }\n        }\n        if (timing)\n            console.log(`Collapse pass ${pass}${conflicts ? `` : `, done`} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);\n        if (!conflicts)\n            return mergeStates(states, mapping);\n    }\n}\nfunction mergeIdentical(states) {\n    for (let pass = 1;; pass++) {\n        let mapping = [], didMerge = false, t0 = Date.now();\n        let newStates = [];\n        // Find states that either have the same alwaysReduce or the same\n        // actions, and merge them.\n        for (let i = 0; i < states.length; i++) {\n            let state = states[i];\n            let match = newStates.findIndex(s => state.eq(s));\n            if (match < 0) {\n                mapping[i] = newStates.length;\n                newStates.push(state);\n            }\n            else {\n                mapping[i] = match;\n                didMerge = true;\n                let other = newStates[match], add = null;\n                for (let pos of state.set)\n                    if (!other.set.some(p => p.eqSimple(pos)))\n                        (add || (add = [])).push(pos);\n                if (add)\n                    other.set = add.concat(other.set).sort((a, b) => a.cmp(b));\n            }\n        }\n        if (timing)\n            console.log(`Merge identical pass ${pass}${didMerge ? \"\" : \", done\"} (${((Date.now() - t0) / 1000).toFixed(2)}s)`);\n        if (!didMerge)\n            return states;\n        // Make sure actions point at merged state objects\n        for (let state of newStates)\n            if (!state.defaultReduce) {\n                state.actions = state.actions.map(a => a.map(mapping, newStates));\n                state.goto = state.goto.map(a => a.map(mapping, newStates));\n            }\n        // Renumber ids\n        for (let i = 0; i < newStates.length; i++)\n            newStates[i].id = i;\n        states = newStates;\n    }\n}\nconst none$1 = [];\nfunction finishAutomaton(full) {\n    return mergeIdentical(collapseAutomaton(full));\n}\n\n// Encode numbers as groups of printable ascii characters\n//\n// - 0xffff, which is often used as placeholder, is encoded as \"~\"\n//\n// - The characters from \" \" (32) to \"}\" (125), excluding '\"' and\n//   \"\\\\\", indicate values from 0 to 92\n//\n// - The first bit in a 'digit' is used to indicate whether this is\n//   the end of a number.\n//\n// - That leaves 46 other values, which are actually significant.\n//\n// - The digits in a number are ordered from high to low significance.\nfunction digitToChar(digit) {\n    let ch = digit + 32 /* Encode.Start */;\n    if (ch >= 34 /* Encode.Gap1 */)\n        ch++;\n    if (ch >= 92 /* Encode.Gap2 */)\n        ch++;\n    return String.fromCharCode(ch);\n}\nfunction encode(value, max = 0xffff) {\n    if (value > max)\n        throw new Error(\"Trying to encode a number that's too big: \" + value);\n    if (value == 65535 /* Encode.BigVal */)\n        return String.fromCharCode(126 /* Encode.BigValCode */);\n    let result = \"\";\n    for (let first = 46 /* Encode.Base */;; first = 0) {\n        let low = value % 46 /* Encode.Base */, rest = value - low;\n        result = digitToChar(low + first) + result;\n        if (rest == 0)\n            break;\n        value = rest / 46 /* Encode.Base */;\n    }\n    return result;\n}\nfunction encodeArray(values, max = 0xffff) {\n    let result = '\"' + encode(values.length, 0xffffffff);\n    for (let i = 0; i < values.length; i++)\n        result += encode(values[i], max);\n    result += '\"';\n    return result;\n}\n\nconst none = [];\nclass Parts {\n    constructor(terms, conflicts) {\n        this.terms = terms;\n        this.conflicts = conflicts;\n    }\n    concat(other) {\n        if (this == Parts.none)\n            return other;\n        if (other == Parts.none)\n            return this;\n        let conflicts = null;\n        if (this.conflicts || other.conflicts) {\n            conflicts = this.conflicts ? this.conflicts.slice() : this.ensureConflicts();\n            let otherConflicts = other.ensureConflicts();\n            conflicts[conflicts.length - 1] = conflicts[conflicts.length - 1].join(otherConflicts[0]);\n            for (let i = 1; i < otherConflicts.length; i++)\n                conflicts.push(otherConflicts[i]);\n        }\n        return new Parts(this.terms.concat(other.terms), conflicts);\n    }\n    withConflicts(pos, conflicts) {\n        if (conflicts == Conflicts.none)\n            return this;\n        let array = this.conflicts ? this.conflicts.slice() : this.ensureConflicts();\n        array[pos] = array[pos].join(conflicts);\n        return new Parts(this.terms, array);\n    }\n    ensureConflicts() {\n        if (this.conflicts)\n            return this.conflicts;\n        let empty = [];\n        for (let i = 0; i <= this.terms.length; i++)\n            empty.push(Conflicts.none);\n        return empty;\n    }\n}\nParts.none = new Parts(none, null);\nfunction p(...terms) { return new Parts(terms, null); }\nclass BuiltRule {\n    constructor(id, args, term) {\n        this.id = id;\n        this.args = args;\n        this.term = term;\n    }\n    matches(expr) {\n        return this.id == expr.id.name && exprsEq(expr.args, this.args);\n    }\n    matchesRepeat(expr) {\n        return this.id == \"+\" && exprEq(expr.expr, this.args[0]);\n    }\n}\nclass Builder {\n    constructor(text, options) {\n        this.options = options;\n        this.terms = new TermSet;\n        this.specialized = Object.create(null);\n        this.tokenOrigins = Object.create(null);\n        this.rules = [];\n        this.built = [];\n        this.ruleNames = Object.create(null);\n        this.namespaces = Object.create(null);\n        this.namedTerms = Object.create(null);\n        this.termTable = Object.create(null);\n        this.knownProps = Object.create(null);\n        this.dynamicRulePrecedences = [];\n        this.definedGroups = [];\n        this.astRules = [];\n        this.currentSkip = [];\n        time(\"Parse\", () => {\n            this.input = new Input(text, options.fileName);\n            this.ast = this.input.parse();\n        });\n        let NP = NodeProp;\n        for (let prop in NP) {\n            if (NP[prop] instanceof NodeProp && !NP[prop].perNode)\n                this.knownProps[prop] = { prop: NP[prop], source: { name: prop, from: null } };\n        }\n        for (let prop of this.ast.externalProps) {\n            this.knownProps[prop.id.name] = {\n                prop: this.options.externalProp ? this.options.externalProp(prop.id.name) : new NodeProp(),\n                source: { name: prop.externalID.name, from: prop.source }\n            };\n        }\n        this.dialects = this.ast.dialects.map(d => d.name);\n        this.tokens = new MainTokenSet(this, this.ast.tokens);\n        this.localTokens = this.ast.localTokens.map(g => new LocalTokenSet(this, g));\n        this.externalTokens = this.ast.externalTokens.map(ext => new ExternalTokenSet(this, ext));\n        this.externalSpecializers = this.ast.externalSpecializers.map(decl => new ExternalSpecializer(this, decl));\n        time(\"Build rules\", () => {\n            let noSkip = this.newName(\"%noskip\", true);\n            this.defineRule(noSkip, []);\n            let mainSkip = this.ast.mainSkip ? this.newName(\"%mainskip\", true) : noSkip;\n            let scopedSkip = [], topRules = [];\n            for (let rule of this.ast.rules)\n                this.astRules.push({ skip: mainSkip, rule });\n            for (let rule of this.ast.topRules)\n                topRules.push({ skip: mainSkip, rule });\n            for (let scoped of this.ast.scopedSkip) {\n                let skip = noSkip, found = this.ast.scopedSkip.findIndex((sc, i) => i < scopedSkip.length && exprEq(sc.expr, scoped.expr));\n                if (found > -1)\n                    skip = scopedSkip[found];\n                else if (this.ast.mainSkip && exprEq(scoped.expr, this.ast.mainSkip))\n                    skip = mainSkip;\n                else if (!isEmpty(scoped.expr))\n                    skip = this.newName(\"%skip\", true);\n                scopedSkip.push(skip);\n                for (let rule of scoped.rules)\n                    this.astRules.push({ skip, rule });\n                for (let rule of scoped.topRules)\n                    topRules.push({ skip, rule });\n            }\n            for (let { rule } of this.astRules) {\n                this.unique(rule.id);\n            }\n            this.currentSkip.push(noSkip);\n            this.skipRules = mainSkip == noSkip ? [mainSkip] : [noSkip, mainSkip];\n            if (mainSkip != noSkip)\n                this.defineRule(mainSkip, this.normalizeExpr(this.ast.mainSkip));\n            for (let i = 0; i < this.ast.scopedSkip.length; i++) {\n                let skip = scopedSkip[i];\n                if (!this.skipRules.includes(skip)) {\n                    this.skipRules.push(skip);\n                    if (skip != noSkip)\n                        this.defineRule(skip, this.normalizeExpr(this.ast.scopedSkip[i].expr));\n                }\n            }\n            this.currentSkip.pop();\n            for (let { rule, skip } of topRules.sort((a, b) => a.rule.start - b.rule.start)) {\n                this.unique(rule.id);\n                this.used(rule.id.name);\n                this.currentSkip.push(skip);\n                let { name, props } = this.nodeInfo(rule.props, \"a\", rule.id.name, none, none, rule.expr);\n                let term = this.terms.makeTop(name, props);\n                this.namedTerms[name] = term;\n                this.defineRule(term, this.normalizeExpr(rule.expr));\n                this.currentSkip.pop();\n            }\n            for (let ext of this.externalSpecializers)\n                ext.finish();\n            for (let { skip, rule } of this.astRules) {\n                if (this.ruleNames[rule.id.name] && isExported(rule) && !rule.params.length) {\n                    this.buildRule(rule, [], skip, false);\n                    if (rule.expr instanceof SequenceExpression && rule.expr.exprs.length == 0)\n                        this.used(rule.id.name);\n                }\n            }\n        });\n        for (let name in this.ruleNames) {\n            let value = this.ruleNames[name];\n            if (value)\n                this.warn(`Unused rule '${value.name}'`, value.start);\n        }\n        this.tokens.takePrecedences();\n        this.tokens.takeConflicts();\n        for (let lt of this.localTokens)\n            lt.takePrecedences();\n        for (let { name, group, rule } of this.definedGroups)\n            this.defineGroup(name, group, rule);\n        this.checkGroups();\n    }\n    unique(id) {\n        if (id.name in this.ruleNames)\n            this.raise(`Duplicate definition of rule '${id.name}'`, id.start);\n        this.ruleNames[id.name] = id;\n    }\n    used(name) {\n        this.ruleNames[name] = null;\n    }\n    newName(base, nodeName = null, props = {}) {\n        for (let i = nodeName ? 0 : 1;; i++) {\n            let name = i ? `${base}-${i}` : base;\n            if (!this.terms.names[name])\n                return this.terms.makeNonTerminal(name, nodeName === true ? null : nodeName, props);\n        }\n    }\n    prepareParser() {\n        let rules = time(\"Simplify rules\", () => simplifyRules(this.rules, [\n            ...this.skipRules,\n            ...this.terms.tops\n        ]));\n        let { nodeTypes, names: termNames, minRepeatTerm, maxTerm } = this.terms.finish(rules);\n        for (let prop in this.namedTerms)\n            this.termTable[prop] = this.namedTerms[prop].id;\n        if (/\\bgrammar\\b/.test(verbose))\n            console.log(rules.join(\"\\n\"));\n        let startTerms = this.terms.tops.slice();\n        let first = computeFirstSets(this.terms);\n        let skipInfo = this.skipRules.map((name, id) => {\n            let skip = [], startTokens = [], rules = [];\n            for (let rule of name.rules) {\n                if (!rule.parts.length)\n                    continue;\n                let start = rule.parts[0];\n                for (let t of start.terminal ? [start] : first[start.name] || [])\n                    if (t && !startTokens.includes(t))\n                        startTokens.push(t);\n                if (start.terminal && rule.parts.length == 1 && !rules.some(r => r != rule && r.parts[0] == start))\n                    skip.push(start);\n                else\n                    rules.push(rule);\n            }\n            name.rules = rules;\n            if (rules.length)\n                startTerms.push(name);\n            return { skip, rule: rules.length ? name : null, startTokens, id };\n        });\n        let fullTable = time(\"Build full automaton\", () => buildFullAutomaton(this.terms, startTerms, first));\n        let localTokens = this.localTokens\n            .map((grp, i) => grp.buildLocalGroup(fullTable, skipInfo, i));\n        let { tokenGroups, tokenPrec, tokenData } = time(\"Build token groups\", () => this.tokens.buildTokenGroups(fullTable, skipInfo, localTokens.length));\n        let table = time(\"Finish automaton\", () => finishAutomaton(fullTable));\n        let skipState = findSkipStates(table, this.terms.tops);\n        if (/\\blr\\b/.test(verbose))\n            console.log(table.join(\"\\n\"));\n        let specialized = [];\n        for (let ext of this.externalSpecializers)\n            specialized.push(ext);\n        for (let name in this.specialized)\n            specialized.push({ token: this.terms.names[name], table: buildSpecializeTable(this.specialized[name]) });\n        let tokStart = (tokenizer) => {\n            if (tokenizer instanceof ExternalTokenSet)\n                return tokenizer.ast.start;\n            return this.tokens.ast ? this.tokens.ast.start : -1;\n        };\n        let tokenizers = tokenGroups\n            .concat(this.externalTokens)\n            .sort((a, b) => tokStart(a) - tokStart(b))\n            .concat(localTokens);\n        let data = new DataBuilder;\n        let skipData = skipInfo.map(info => {\n            let actions = [];\n            for (let term of info.skip)\n                actions.push(term.id, 0, 262144 /* Action.StayFlag */ >> 16);\n            if (info.rule) {\n                let state = table.find(s => s.startRule == info.rule);\n                for (let action of state.actions)\n                    actions.push(action.term.id, state.id, 131072 /* Action.GotoFlag */ >> 16);\n            }\n            actions.push(65535 /* Seq.End */, 0 /* Seq.Done */);\n            return data.storeArray(actions);\n        });\n        let states = time(\"Finish states\", () => {\n            let states = new Uint32Array(table.length * 6 /* ParseState.Size */);\n            let forceReductions = this.computeForceReductions(table, skipInfo);\n            let finishCx = new FinishStateContext(tokenizers, data, states, skipData, skipInfo, table, this);\n            for (let s of table)\n                finishCx.finish(s, skipState(s.id), forceReductions[s.id]);\n            return states;\n        });\n        let dialects = Object.create(null);\n        for (let i = 0; i < this.dialects.length; i++)\n            dialects[this.dialects[i]] = data.storeArray((this.tokens.byDialect[i] || none).map(t => t.id).concat(65535 /* Seq.End */));\n        let dynamicPrecedences = null;\n        if (this.dynamicRulePrecedences.length) {\n            dynamicPrecedences = Object.create(null);\n            for (let { rule, prec } of this.dynamicRulePrecedences)\n                dynamicPrecedences[rule.id] = prec;\n        }\n        let topRules = Object.create(null);\n        for (let term of this.terms.tops)\n            topRules[term.nodeName] = [table.find(state => state.startRule == term).id, term.id];\n        let precTable = data.storeArray(tokenPrec.concat(65535 /* Seq.End */));\n        let { nodeProps, skippedTypes } = this.gatherNodeProps(nodeTypes);\n        return {\n            states,\n            stateData: data.finish(),\n            goto: computeGotoTable(table),\n            nodeNames: nodeTypes.filter(t => t.id < minRepeatTerm).map(t => t.nodeName).join(\" \"),\n            nodeProps,\n            skippedTypes,\n            maxTerm,\n            repeatNodeCount: nodeTypes.length - minRepeatTerm,\n            tokenizers,\n            tokenData,\n            topRules,\n            dialects,\n            dynamicPrecedences,\n            specialized,\n            tokenPrec: precTable,\n            termNames\n        };\n    }\n    getParser() {\n        let { states, stateData, goto, nodeNames, nodeProps: rawNodeProps, skippedTypes, maxTerm, repeatNodeCount, tokenizers, tokenData, topRules, dialects, dynamicPrecedences, specialized: rawSpecialized, tokenPrec, termNames } = this.prepareParser();\n        let specialized = rawSpecialized.map(v => {\n            if (v instanceof ExternalSpecializer) {\n                let ext = this.options.externalSpecializer(v.ast.id.name, this.termTable);\n                return {\n                    term: v.term.id,\n                    get: (value, stack) => (ext(value, stack) << 1) |\n                        (v.ast.type == \"extend\" ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */),\n                    external: ext,\n                    extend: v.ast.type == \"extend\"\n                };\n            }\n            else {\n                return { term: v.token.id, get: (value) => v.table[value] || -1 };\n            }\n        });\n        return LRParser.deserialize({\n            version: 14 /* File.Version */,\n            states,\n            stateData,\n            goto,\n            nodeNames,\n            maxTerm,\n            repeatNodeCount,\n            nodeProps: rawNodeProps.map(({ prop, terms }) => [this.knownProps[prop].prop, ...terms]),\n            propSources: !this.options.externalPropSource ? undefined\n                : this.ast.externalPropSources.map(s => this.options.externalPropSource(s.id.name)),\n            skippedNodes: skippedTypes,\n            tokenData,\n            tokenizers: tokenizers.map(tok => tok.create()),\n            context: !this.ast.context ? undefined\n                : typeof this.options.contextTracker == \"function\" ? this.options.contextTracker(this.termTable)\n                    : this.options.contextTracker,\n            topRules,\n            dialects,\n            dynamicPrecedences,\n            specialized,\n            tokenPrec,\n            termNames\n        });\n    }\n    getParserFile() {\n        let { states, stateData, goto, nodeNames, nodeProps: rawNodeProps, skippedTypes, maxTerm, repeatNodeCount, tokenizers: rawTokenizers, tokenData, topRules, dialects: rawDialects, dynamicPrecedences, specialized: rawSpecialized, tokenPrec, termNames } = this.prepareParser();\n        let mod = this.options.moduleStyle || \"es\";\n        let gen = \"// This file was generated by lezer-generator. You probably shouldn't edit it.\\n\", head = gen;\n        let imports = {}, imported = Object.create(null);\n        let defined = Object.create(null);\n        for (let word of KEYWORDS)\n            defined[word] = true;\n        let exportName = this.options.exportName || \"parser\";\n        defined[exportName] = true;\n        let getName = (prefix) => {\n            for (let i = 0;; i++) {\n                let id = prefix + (i ? \"_\" + i : \"\");\n                if (!defined[id])\n                    return id;\n            }\n        };\n        let importName = (name, source, prefix = name) => {\n            let spec = name + \" from \" + source;\n            if (imported[spec])\n                return imported[spec];\n            let src = JSON.stringify(source), varName = name;\n            if (name in defined) {\n                varName = getName(prefix);\n                name += `${mod == \"cjs\" ? \":\" : \" as\"} ${varName}`;\n            }\n            defined[varName] = true;\n            (imports[src] || (imports[src] = [])).push(name);\n            return imported[spec] = varName;\n        };\n        let lrParser = importName(\"LRParser\", \"@lezer/lr\");\n        let tokenizers = rawTokenizers.map(tok => tok.createSource(importName));\n        let context = this.ast.context ? importName(this.ast.context.id.name, this.ast.context.source) : null;\n        let nodeProps = rawNodeProps.map(({ prop, terms }) => {\n            let { source } = this.knownProps[prop];\n            let propID = source.from ? importName(source.name, source.from) : JSON.stringify(source.name);\n            return `[${propID}, ${terms.map(serializePropValue).join(\",\")}]`;\n        });\n        function specializationTableString(table) {\n            return \"{__proto__:null,\" + Object.keys(table).map(key => `${/^(\\d+|[a-zA-Z_]\\w*)$/.test(key) ? key : JSON.stringify(key)}:${table[key]}`)\n                .join(\", \") + \"}\";\n        }\n        let specHead = \"\";\n        let specialized = rawSpecialized.map(v => {\n            if (v instanceof ExternalSpecializer) {\n                let name = importName(v.ast.id.name, v.ast.source);\n                let ts = this.options.typeScript ? \": any\" : \"\";\n                return `{term: ${v.term.id}, get: (value${ts}, stack${ts}) => (${name}(value, stack) << 1)${v.ast.type == \"extend\" ? ` | ${1 /* Specialize.Extend */}` : ''}, external: ${name}${v.ast.type == \"extend\" ? ', extend: true' : ''}}`;\n            }\n            else {\n                let tableName = getName(\"spec_\" + v.token.name.replace(/\\W/g, \"\"));\n                defined[tableName] = true;\n                specHead += `const ${tableName} = ${specializationTableString(v.table)}\\n`;\n                let ts = this.options.typeScript ? `: keyof typeof ${tableName}` : \"\";\n                return `{term: ${v.token.id}, get: (value${ts}) => ${tableName}[value] || -1}`;\n            }\n        });\n        let propSources = this.ast.externalPropSources.map(s => importName(s.id.name, s.source));\n        for (let source in imports) {\n            if (mod == \"cjs\")\n                head += `const {${imports[source].join(\", \")}} = require(${source})\\n`;\n            else\n                head += `import {${imports[source].join(\", \")}} from ${source}\\n`;\n        }\n        head += specHead;\n        function serializePropValue(value) {\n            return typeof value != \"string\" || /^(true|false|\\d+(\\.\\d+)?|\\.\\d+)$/.test(value) ? value : JSON.stringify(value);\n        }\n        let dialects = Object.keys(rawDialects).map(d => `${d}: ${rawDialects[d]}`);\n        let parserStr = `${lrParser}.deserialize({\n  version: ${14 /* File.Version */},\n  states: ${encodeArray(states, 0xffffffff)},\n  stateData: ${encodeArray(stateData)},\n  goto: ${encodeArray(goto)},\n  nodeNames: ${JSON.stringify(nodeNames)},\n  maxTerm: ${maxTerm}${context ? `,\n  context: ${context}` : \"\"}${nodeProps.length ? `,\n  nodeProps: [\n    ${nodeProps.join(\",\\n    \")}\n  ]` : \"\"}${propSources.length ? `,\n  propSources: [${propSources.join()}]` : \"\"}${skippedTypes.length ? `,\n  skippedNodes: ${JSON.stringify(skippedTypes)}` : \"\"},\n  repeatNodeCount: ${repeatNodeCount},\n  tokenData: ${encodeArray(tokenData)},\n  tokenizers: [${tokenizers.join(\", \")}],\n  topRules: ${JSON.stringify(topRules)}${dialects.length ? `,\n  dialects: {${dialects.join(\", \")}}` : \"\"}${dynamicPrecedences ? `,\n  dynamicPrecedences: ${JSON.stringify(dynamicPrecedences)}` : \"\"}${specialized.length ? `,\n  specialized: [${specialized.join(\",\")}]` : \"\"},\n  tokenPrec: ${tokenPrec}${this.options.includeNames ? `,\n  termNames: ${JSON.stringify(termNames)}` : ''}\n})`;\n        let terms = [];\n        for (let name in this.termTable) {\n            let id = name;\n            if (KEYWORDS.includes(id))\n                for (let i = 1;; i++) {\n                    id = \"_\".repeat(i) + name;\n                    if (!(id in this.termTable))\n                        break;\n                }\n            else if (!/^[\\w$]+$/.test(name)) {\n                continue;\n            }\n            terms.push(`${id}${mod == \"cjs\" ? \":\" : \" =\"} ${this.termTable[name]}`);\n        }\n        for (let id = 0; id < this.dialects.length; id++)\n            terms.push(`Dialect_${this.dialects[id]}${mod == \"cjs\" ? \":\" : \" =\"} ${id}`);\n        return {\n            parser: head + (mod == \"cjs\" ? `exports.${exportName} = ${parserStr}\\n` : `export const ${exportName} = ${parserStr}\\n`),\n            terms: mod == \"cjs\" ? `${gen}module.exports = {\\n  ${terms.join(\",\\n  \")}\\n}`\n                : `${gen}export const\\n  ${terms.join(\",\\n  \")}\\n`\n        };\n    }\n    gatherNonSkippedNodes() {\n        let seen = Object.create(null);\n        let work = [];\n        let add = (term) => {\n            if (!seen[term.id]) {\n                seen[term.id] = true;\n                work.push(term);\n            }\n        };\n        this.terms.tops.forEach(add);\n        for (let i = 0; i < work.length; i++) {\n            for (let rule of work[i].rules)\n                for (let part of rule.parts)\n                    add(part);\n        }\n        return seen;\n    }\n    gatherNodeProps(nodeTypes) {\n        let notSkipped = this.gatherNonSkippedNodes(), skippedTypes = [];\n        let nodeProps = [];\n        for (let type of nodeTypes) {\n            if (!notSkipped[type.id] && !type.error)\n                skippedTypes.push(type.id);\n            for (let prop in type.props) {\n                let known = this.knownProps[prop];\n                if (!known)\n                    throw new GenError(\"No known prop type for \" + prop);\n                if (known.source.from == null && (known.source.name == \"repeated\" || known.source.name == \"error\"))\n                    continue;\n                let rec = nodeProps.find(r => r.prop == prop);\n                if (!rec)\n                    nodeProps.push(rec = { prop, values: {} });\n                (rec.values[type.props[prop]] || (rec.values[type.props[prop]] = [])).push(type.id);\n            }\n        }\n        return {\n            nodeProps: nodeProps.map(({ prop, values }) => {\n                let terms = [];\n                for (let val in values) {\n                    let ids = values[val];\n                    if (ids.length == 1) {\n                        terms.push(ids[0], val);\n                    }\n                    else {\n                        terms.push(-ids.length);\n                        for (let id of ids)\n                            terms.push(id);\n                        terms.push(val);\n                    }\n                }\n                return { prop, terms };\n            }),\n            skippedTypes\n        };\n    }\n    makeTerminal(name, tag, props) {\n        return this.terms.makeTerminal(this.terms.uniqueName(name), tag, props);\n    }\n    computeForceReductions(states, skipInfo) {\n        // This finds a forced reduction for every state, trying to guard\n        // against cyclic forced reductions, where a given parse stack can\n        // endlessly continue running forced reductions without making any\n        // progress.\n        //\n        // This occurs with length-1 reductions. We never generate\n        // length-0 reductions, and length-2+ reductions always shrink the\n        // stack, so they are guaranteed to make progress.\n        //\n        // If there are states S1 and S2 whose forced reductions reduce\n        // terms T1 and T2 respectively, both with a length of 1, _and_\n        // there is a state S3, which has goto entries T1 -> S2, T2 -> S1,\n        // you can get cyclic reductions. Of course, the cycle may also\n        // contain more than two steps.\n        let reductions = [];\n        let candidates = [];\n        // A map from terms to states that they are mapped to in goto\n        // entries.\n        let gotoEdges = Object.create(null);\n        for (let state of states) {\n            reductions.push(0);\n            for (let edge of state.goto) {\n                let array = gotoEdges[edge.term.id] || (gotoEdges[edge.term.id] = []);\n                let found = array.find(o => o.target == edge.target.id);\n                if (found)\n                    found.parents.push(state.id);\n                else\n                    array.push({ parents: [state.id], target: edge.target.id });\n            }\n            candidates[state.id] = state.set.filter(pos => pos.pos > 0 && !pos.rule.name.top)\n                .sort((a, b) => b.pos - a.pos || a.rule.parts.length - b.rule.parts.length);\n        }\n        // Mapping from state ids to terms that that state has a length-1\n        // forced reduction for.\n        let length1Reductions = Object.create(null);\n        function createsCycle(term, startState, parents = null) {\n            let edges = gotoEdges[term];\n            if (!edges)\n                return false;\n            return edges.some(val => {\n                let parentIntersection = parents ? parents.filter(id => val.parents.includes(id)) : val.parents;\n                if (parentIntersection.length == 0)\n                    return false;\n                if (val.target == startState)\n                    return true;\n                let found = length1Reductions[val.target];\n                return found != null && createsCycle(found, startState, parentIntersection);\n            });\n        }\n        for (let state of states) {\n            if (state.defaultReduce && state.defaultReduce.parts.length > 0) {\n                reductions[state.id] = reduceAction(state.defaultReduce, skipInfo);\n                if (state.defaultReduce.parts.length == 1)\n                    length1Reductions[state.id] = state.defaultReduce.name.id;\n            }\n        }\n        // To avoid painting states that only have one potential forced\n        // reduction into a corner, reduction assignment is done by\n        // candidate size, starting with the states with fewer candidates.\n        for (let setSize = 1;; setSize++) {\n            let done = true;\n            for (let state of states) {\n                if (state.defaultReduce)\n                    continue;\n                let set = candidates[state.id];\n                if (set.length != setSize) {\n                    if (set.length > setSize)\n                        done = false;\n                    continue;\n                }\n                for (let pos of set) {\n                    if (pos.pos != 1 || !createsCycle(pos.rule.name.id, state.id)) {\n                        reductions[state.id] = reduceAction(pos.rule, skipInfo, pos.pos);\n                        if (pos.pos == 1)\n                            length1Reductions[state.id] = pos.rule.name.id;\n                        break;\n                    }\n                }\n            }\n            if (done)\n                break;\n        }\n        return reductions;\n    }\n    substituteArgs(expr, args, params) {\n        if (args.length == 0)\n            return expr;\n        return expr.walk(expr => {\n            let found;\n            if (expr instanceof NameExpression &&\n                (found = params.findIndex(p => p.name == expr.id.name)) > -1) {\n                let arg = args[found];\n                if (expr.args.length) {\n                    if (arg instanceof NameExpression && !arg.args.length)\n                        return new NameExpression(expr.start, arg.id, expr.args);\n                    this.raise(`Passing arguments to a parameter that already has arguments`, expr.start);\n                }\n                return arg;\n            }\n            else if (expr instanceof InlineRuleExpression) {\n                let r = expr.rule, props = this.substituteArgsInProps(r.props, args, params);\n                return props == r.props ? expr :\n                    new InlineRuleExpression(expr.start, new RuleDeclaration(r.start, r.id, props, r.params, r.expr));\n            }\n            else if (expr instanceof SpecializeExpression) {\n                let props = this.substituteArgsInProps(expr.props, args, params);\n                return props == expr.props ? expr :\n                    new SpecializeExpression(expr.start, expr.type, props, expr.token, expr.content);\n            }\n            return expr;\n        });\n    }\n    substituteArgsInProps(props, args, params) {\n        let substituteInValue = (value) => {\n            let result = value;\n            for (let i = 0; i < value.length; i++) {\n                let part = value[i];\n                if (!part.name)\n                    continue;\n                let found = params.findIndex(p => p.name == part.name);\n                if (found < 0)\n                    continue;\n                if (result == value)\n                    result = value.slice();\n                let expr = args[found];\n                if (expr instanceof NameExpression && !expr.args.length)\n                    result[i] = new PropPart(part.start, expr.id.name, null);\n                else if (expr instanceof LiteralExpression)\n                    result[i] = new PropPart(part.start, expr.value, null);\n                else\n                    this.raise(`Trying to interpolate expression '${expr}' into a prop`, part.start);\n            }\n            return result;\n        };\n        let result = props;\n        for (let i = 0; i < props.length; i++) {\n            let prop = props[i], value = substituteInValue(prop.value);\n            if (value != prop.value) {\n                if (result == props)\n                    result = props.slice();\n                result[i] = new Prop(prop.start, prop.at, prop.name, value);\n            }\n        }\n        return result;\n    }\n    conflictsFor(markers) {\n        let here = Conflicts.none, atEnd = Conflicts.none;\n        for (let marker of markers) {\n            if (marker.type == \"ambig\") {\n                here = here.join(new Conflicts(0, [marker.id.name]));\n            }\n            else {\n                let precs = this.ast.precedences;\n                let index = precs ? precs.items.findIndex(item => item.id.name == marker.id.name) : -1;\n                if (index < 0)\n                    this.raise(`Reference to unknown precedence: '${marker.id.name}'`, marker.id.start);\n                let prec = precs.items[index], value = precs.items.length - index;\n                if (prec.type == \"cut\") {\n                    here = here.join(new Conflicts(0, none, value));\n                }\n                else {\n                    here = here.join(new Conflicts(value << 2));\n                    atEnd = atEnd.join(new Conflicts((value << 2) + (prec.type == \"left\" ? 1 : prec.type == \"right\" ? -1 : 0)));\n                }\n            }\n        }\n        return { here, atEnd };\n    }\n    raise(message, pos = 1) {\n        return this.input.raise(message, pos);\n    }\n    warn(message, pos = -1) {\n        let msg = this.input.message(message, pos);\n        if (this.options.warn)\n            this.options.warn(msg);\n        else\n            console.warn(msg);\n    }\n    defineRule(name, choices) {\n        let skip = this.currentSkip[this.currentSkip.length - 1];\n        for (let choice of choices)\n            this.rules.push(new Rule(name, choice.terms, choice.ensureConflicts(), skip));\n    }\n    resolve(expr) {\n        for (let built of this.built)\n            if (built.matches(expr))\n                return [p(built.term)];\n        let found = this.tokens.getToken(expr);\n        if (found)\n            return [p(found)];\n        for (let grp of this.localTokens) {\n            let found = grp.getToken(expr);\n            if (found)\n                return [p(found)];\n        }\n        for (let ext of this.externalTokens) {\n            let found = ext.getToken(expr);\n            if (found)\n                return [p(found)];\n        }\n        for (let ext of this.externalSpecializers) {\n            let found = ext.getToken(expr);\n            if (found)\n                return [p(found)];\n        }\n        let known = this.astRules.find(r => r.rule.id.name == expr.id.name);\n        if (!known)\n            return this.raise(`Reference to undefined rule '${expr.id.name}'`, expr.start);\n        if (known.rule.params.length != expr.args.length)\n            this.raise(`Wrong number or arguments for '${expr.id.name}'`, expr.start);\n        this.used(known.rule.id.name);\n        return [p(this.buildRule(known.rule, expr.args, known.skip))];\n    }\n    // For tree-balancing reasons, repeat expressions X+ have to be\n    // normalized to something like\n    //\n    //     R -> X | R R\n    //\n    // Returns the `R` term.\n    normalizeRepeat(expr) {\n        let known = this.built.find(b => b.matchesRepeat(expr));\n        if (known)\n            return p(known.term);\n        let name = expr.expr.prec < expr.prec ? `(${expr.expr})+` : `${expr.expr}+`;\n        let term = this.terms.makeRepeat(this.terms.uniqueName(name));\n        this.built.push(new BuiltRule(\"+\", [expr.expr], term));\n        this.defineRule(term, this.normalizeExpr(expr.expr).concat(p(term, term)));\n        return p(term);\n    }\n    normalizeSequence(expr) {\n        let result = expr.exprs.map(e => this.normalizeExpr(e));\n        let builder = this;\n        function complete(start, from, endConflicts) {\n            let { here, atEnd } = builder.conflictsFor(expr.markers[from]);\n            if (from == result.length)\n                return [start.withConflicts(start.terms.length, here.join(endConflicts))];\n            let choices = [];\n            for (let choice of result[from]) {\n                for (let full of complete(start.concat(choice).withConflicts(start.terms.length, here), from + 1, endConflicts.join(atEnd)))\n                    choices.push(full);\n            }\n            return choices;\n        }\n        return complete(Parts.none, 0, Conflicts.none);\n    }\n    normalizeExpr(expr) {\n        if (expr instanceof RepeatExpression && expr.kind == \"?\") {\n            return [Parts.none, ...this.normalizeExpr(expr.expr)];\n        }\n        else if (expr instanceof RepeatExpression) {\n            let repeated = this.normalizeRepeat(expr);\n            return expr.kind == \"+\" ? [repeated] : [Parts.none, repeated];\n        }\n        else if (expr instanceof ChoiceExpression) {\n            return expr.exprs.reduce((o, e) => o.concat(this.normalizeExpr(e)), []);\n        }\n        else if (expr instanceof SequenceExpression) {\n            return this.normalizeSequence(expr);\n        }\n        else if (expr instanceof LiteralExpression) {\n            return [p(this.tokens.getLiteral(expr))];\n        }\n        else if (expr instanceof NameExpression) {\n            return this.resolve(expr);\n        }\n        else if (expr instanceof SpecializeExpression) {\n            return [p(this.resolveSpecialization(expr))];\n        }\n        else if (expr instanceof InlineRuleExpression) {\n            return [p(this.buildRule(expr.rule, none, this.currentSkip[this.currentSkip.length - 1], true))];\n        }\n        else {\n            return this.raise(`This type of expression ('${expr}') may not occur in non-token rules`, expr.start);\n        }\n    }\n    buildRule(rule, args, skip, inline = false) {\n        let expr = this.substituteArgs(rule.expr, args, rule.params);\n        let { name: nodeName, props, dynamicPrec, inline: explicitInline, group, exported } = this.nodeInfo(rule.props || none, inline ? \"pg\" : \"pgi\", rule.id.name, args, rule.params, rule.expr);\n        if (exported && rule.params.length)\n            this.warn(`Can't export parameterized rules`, rule.start);\n        if (exported && inline)\n            this.warn(`Can't export inline rule`, rule.start);\n        let name = this.newName(rule.id.name + (args.length ? \"<\" + args.join(\",\") + \">\" : \"\"), nodeName || true, props);\n        if (explicitInline)\n            name.inline = true;\n        if (dynamicPrec)\n            this.registerDynamicPrec(name, dynamicPrec);\n        if ((name.nodeType || exported) && rule.params.length == 0) {\n            if (!nodeName)\n                name.preserve = true;\n            if (!inline)\n                this.namedTerms[exported || rule.id.name] = name;\n        }\n        if (!inline)\n            this.built.push(new BuiltRule(rule.id.name, args, name));\n        this.currentSkip.push(skip);\n        let parts = this.normalizeExpr(expr);\n        if (parts.length > 100 * (expr instanceof ChoiceExpression ? expr.exprs.length : 1))\n            this.warn(`Rule ${rule.id.name} is generating a lot (${parts.length}) of choices.\\n  Consider splitting it up or reducing the amount of ? or | operator uses.`, rule.start);\n        if (/\\brulesize\\b/.test(verbose) && parts.length > 10)\n            console.log(`Rule ${rule.id.name}: ${parts.length} variants`);\n        this.defineRule(name, parts);\n        this.currentSkip.pop();\n        if (group)\n            this.definedGroups.push({ name, group, rule });\n        return name;\n    }\n    nodeInfo(props, \n    // p for dynamic precedence, d for dialect, i for inline, g for group, a for disabling the ignore test for default name\n    allow, defaultName = null, args = none, params = none, expr, defaultProps) {\n        let result = {};\n        let name = defaultName && (allow.indexOf(\"a\") > -1 || !ignored(defaultName)) && !/ /.test(defaultName) ? defaultName : null;\n        let dialect = null, dynamicPrec = 0, inline = false, group = null, exported = null;\n        for (let prop of props) {\n            if (!prop.at) {\n                if (!this.knownProps[prop.name]) {\n                    let builtin = [\"name\", \"dialect\", \"dynamicPrecedence\", \"export\", \"isGroup\"].includes(prop.name)\n                        ? ` (did you mean '@${prop.name}'?)` : \"\";\n                    this.raise(`Unknown prop name '${prop.name}'${builtin}`, prop.start);\n                }\n                result[prop.name] = this.finishProp(prop, args, params);\n            }\n            else if (prop.name == \"name\") {\n                name = this.finishProp(prop, args, params);\n                if (/ /.test(name))\n                    this.raise(`Node names cannot have spaces ('${name}')`, prop.start);\n            }\n            else if (prop.name == \"dialect\") {\n                if (allow.indexOf(\"d\") < 0)\n                    this.raise(\"Can't specify a dialect on non-token rules\", props[0].start);\n                if (prop.value.length != 1 && !prop.value[0].value)\n                    this.raise(\"The '@dialect' rule prop must hold a plain string value\");\n                let dialectID = this.dialects.indexOf(prop.value[0].value);\n                if (dialectID < 0)\n                    this.raise(`Unknown dialect '${prop.value[0].value}'`, prop.value[0].start);\n                dialect = dialectID;\n            }\n            else if (prop.name == \"dynamicPrecedence\") {\n                if (allow.indexOf(\"p\") < 0)\n                    this.raise(\"Dynamic precedence can only be specified on nonterminals\");\n                if (prop.value.length != 1 || !/^-?(?:10|\\d)$/.test(prop.value[0].value))\n                    this.raise(\"The '@dynamicPrecedence' rule prop must hold an integer between -10 and 10\");\n                dynamicPrec = +prop.value[0].value;\n            }\n            else if (prop.name == \"inline\") {\n                if (prop.value.length)\n                    this.raise(\"'@inline' doesn't take a value\", prop.value[0].start);\n                if (allow.indexOf(\"i\") < 0)\n                    this.raise(\"Inline can only be specified on nonterminals\");\n                inline = true;\n            }\n            else if (prop.name == \"isGroup\") {\n                if (allow.indexOf(\"g\") < 0)\n                    this.raise(\"'@isGroup' can only be specified on nonterminals\");\n                group = prop.value.length ? this.finishProp(prop, args, params) : defaultName;\n            }\n            else if (prop.name == \"export\") {\n                if (prop.value.length)\n                    exported = this.finishProp(prop, args, params);\n                else\n                    exported = defaultName;\n            }\n            else {\n                this.raise(`Unknown built-in prop name '@${prop.name}'`, prop.start);\n            }\n        }\n        if (expr && this.ast.autoDelim && (name || hasProps(result))) {\n            let delim = this.findDelimiters(expr);\n            if (delim) {\n                addToProp(delim[0], \"closedBy\", delim[1].nodeName);\n                addToProp(delim[1], \"openedBy\", delim[0].nodeName);\n            }\n        }\n        if (defaultProps && hasProps(defaultProps)) {\n            for (let prop in defaultProps)\n                if (!(prop in result))\n                    result[prop] = defaultProps[prop];\n        }\n        if (hasProps(result) && !name)\n            this.raise(`Node has properties but no name`, props.length ? props[0].start : expr.start);\n        if (inline && (hasProps(result) || dialect || dynamicPrec))\n            this.raise(`Inline nodes can't have props, dynamic precedence, or a dialect`, props[0].start);\n        if (inline && name)\n            name = null;\n        return { name, props: result, dialect, dynamicPrec, inline, group, exported };\n    }\n    finishProp(prop, args, params) {\n        return prop.value.map(part => {\n            if (part.value)\n                return part.value;\n            let pos = params.findIndex(param => param.name == part.name);\n            if (pos < 0)\n                this.raise(`Property refers to '${part.name}', but no parameter by that name is in scope`, part.start);\n            let expr = args[pos];\n            if (expr instanceof NameExpression && !expr.args.length)\n                return expr.id.name;\n            if (expr instanceof LiteralExpression)\n                return expr.value;\n            return this.raise(`Expression '${expr}' can not be used as part of a property value`, part.start);\n        }).join(\"\");\n    }\n    resolveSpecialization(expr) {\n        let type = expr.type;\n        let { name, props, dialect, exported } = this.nodeInfo(expr.props, \"d\");\n        let terminal = this.normalizeExpr(expr.token);\n        if (terminal.length != 1 || terminal[0].terms.length != 1 || !terminal[0].terms[0].terminal)\n            this.raise(`The first argument to '${type}' must resolve to a token`, expr.token.start);\n        let values;\n        if (expr.content instanceof LiteralExpression)\n            values = [expr.content.value];\n        else if ((expr.content instanceof ChoiceExpression) && expr.content.exprs.every(e => e instanceof LiteralExpression))\n            values = expr.content.exprs.map(expr => expr.value);\n        else\n            return this.raise(`The second argument to '${expr.type}' must be a literal or choice of literals`, expr.content.start);\n        let term = terminal[0].terms[0], token = null;\n        let table = this.specialized[term.name] || (this.specialized[term.name] = []);\n        for (let value of values) {\n            let known = table.find(sp => sp.value == value);\n            if (known == null) {\n                if (!token) {\n                    token = this.makeTerminal(term.name + \"/\" + JSON.stringify(value), name, props);\n                    if (dialect != null)\n                        (this.tokens.byDialect[dialect] || (this.tokens.byDialect[dialect] = [])).push(token);\n                }\n                table.push({ value, term: token, type, dialect, name });\n                this.tokenOrigins[token.name] = { spec: term };\n                if (name || exported) {\n                    if (!name)\n                        token.preserve = true;\n                    this.namedTerms[exported || name] = token;\n                }\n            }\n            else {\n                if (known.type != type)\n                    this.raise(`Conflicting specialization types for ${JSON.stringify(value)} of ${term.name} (${type} vs ${known.type})`, expr.start);\n                if (known.dialect != dialect)\n                    this.raise(`Conflicting dialects for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start);\n                if (known.name != name)\n                    this.raise(`Conflicting names for specialization ${JSON.stringify(value)} of ${term.name}`, expr.start);\n                if (token && known.term != token)\n                    this.raise(`Conflicting specialization tokens for ${JSON.stringify(value)} of ${term.name}`, expr.start);\n                token = known.term;\n            }\n        }\n        return token;\n    }\n    findDelimiters(expr) {\n        if (!(expr instanceof SequenceExpression) || expr.exprs.length < 2)\n            return null;\n        let findToken = (expr) => {\n            if (expr instanceof LiteralExpression)\n                return { term: this.tokens.getLiteral(expr), str: expr.value };\n            if (expr instanceof NameExpression && expr.args.length == 0) {\n                let rule = this.ast.rules.find(r => r.id.name == expr.id.name);\n                if (rule)\n                    return findToken(rule.expr);\n                let token = this.tokens.rules.find(r => r.id.name == expr.id.name);\n                if (token && token.expr instanceof LiteralExpression)\n                    return { term: this.tokens.getToken(expr), str: token.expr.value };\n            }\n            return null;\n        };\n        let lastToken = findToken(expr.exprs[expr.exprs.length - 1]);\n        if (!lastToken || !lastToken.term.nodeName)\n            return null;\n        const brackets = [\"()\", \"[]\", \"{}\", \"<>\"];\n        let bracket = brackets.find(b => lastToken.str.indexOf(b[1]) > -1 && lastToken.str.indexOf(b[0]) < 0);\n        if (!bracket)\n            return null;\n        let firstToken = findToken(expr.exprs[0]);\n        if (!firstToken || !firstToken.term.nodeName ||\n            firstToken.str.indexOf(bracket[0]) < 0 || firstToken.str.indexOf(bracket[1]) > -1)\n            return null;\n        return [firstToken.term, lastToken.term];\n    }\n    registerDynamicPrec(term, prec) {\n        this.dynamicRulePrecedences.push({ rule: term, prec });\n        term.preserve = true;\n    }\n    defineGroup(rule, group, ast) {\n        var _a;\n        let recur = [];\n        let getNamed = (rule) => {\n            if (rule.nodeName)\n                return [rule];\n            if (recur.includes(rule))\n                this.raise(`Rule '${ast.id.name}' cannot define a group because it contains a non-named recursive rule ('${rule.name}')`, ast.start);\n            let result = [];\n            recur.push(rule);\n            for (let r of this.rules)\n                if (r.name == rule) {\n                    let names = r.parts.map(getNamed).filter(x => x.length);\n                    if (names.length > 1)\n                        this.raise(`Rule '${ast.id.name}' cannot define a group because some choices produce multiple named nodes`, ast.start);\n                    if (names.length == 1)\n                        for (let n of names[0])\n                            result.push(n);\n                }\n            recur.pop();\n            return result;\n        };\n        for (let name of getNamed(rule))\n            name.props[\"group\"] = (((_a = name.props[\"group\"]) === null || _a === void 0 ? void 0 : _a.split(\" \")) || []).concat(group).sort().join(\" \");\n    }\n    checkGroups() {\n        let groups = Object.create(null), nodeNames = Object.create(null);\n        for (let term of this.terms.terms)\n            if (term.nodeName) {\n                nodeNames[term.nodeName] = true;\n                if (term.props[\"group\"])\n                    for (let group of term.props[\"group\"].split(\" \")) {\n                        (groups[group] || (groups[group] = [])).push(term);\n                    }\n            }\n        let names = Object.keys(groups);\n        for (let i = 0; i < names.length; i++) {\n            let name = names[i], terms = groups[name];\n            if (nodeNames[name])\n                this.warn(`Group name '${name}' conflicts with a node of the same name`);\n            for (let j = i + 1; j < names.length; j++) {\n                let other = groups[names[j]];\n                if (terms.some(t => other.includes(t)) &&\n                    (terms.length > other.length ? other.some(t => !terms.includes(t)) : terms.some(t => !other.includes(t))))\n                    this.warn(`Groups '${name}' and '${names[j]}' overlap without one being a superset of the other`);\n            }\n        }\n    }\n}\nconst MinSharedActions = 5;\nclass FinishStateContext {\n    constructor(tokenizers, data, stateArray, skipData, skipInfo, states, builder) {\n        this.tokenizers = tokenizers;\n        this.data = data;\n        this.stateArray = stateArray;\n        this.skipData = skipData;\n        this.skipInfo = skipInfo;\n        this.states = states;\n        this.builder = builder;\n        this.sharedActions = [];\n    }\n    findSharedActions(state) {\n        if (state.actions.length < MinSharedActions)\n            return null;\n        let found = null;\n        for (let shared of this.sharedActions) {\n            if ((!found || shared.actions.length > found.actions.length) &&\n                shared.actions.every(a => state.actions.some(b => b.eq(a))))\n                found = shared;\n        }\n        if (found)\n            return found;\n        let max = null, scratch = [];\n        for (let i = state.id + 1; i < this.states.length; i++) {\n            let other = this.states[i], fill = 0;\n            if (other.defaultReduce || other.actions.length < MinSharedActions)\n                continue;\n            for (let a of state.actions)\n                for (let b of other.actions)\n                    if (a.eq(b))\n                        scratch[fill++] = a;\n            if (fill >= MinSharedActions && (!max || max.length < fill)) {\n                max = scratch;\n                scratch = [];\n            }\n        }\n        if (!max)\n            return null;\n        let result = { actions: max, addr: this.storeActions(max, -1, null) };\n        this.sharedActions.push(result);\n        return result;\n    }\n    storeActions(actions, skipReduce, shared) {\n        if (skipReduce < 0 && shared && shared.actions.length == actions.length)\n            return shared.addr;\n        let data = [];\n        for (let action of actions) {\n            if (shared && shared.actions.some(a => a.eq(action)))\n                continue;\n            if (action instanceof Shift) {\n                data.push(action.term.id, action.target.id, 0);\n            }\n            else {\n                let code = reduceAction(action.rule, this.skipInfo);\n                if (code != skipReduce)\n                    data.push(action.term.id, code & 65535 /* Action.ValueMask */, code >> 16);\n            }\n        }\n        data.push(65535 /* Seq.End */);\n        if (skipReduce > -1)\n            data.push(2 /* Seq.Other */, skipReduce & 65535 /* Action.ValueMask */, skipReduce >> 16);\n        else if (shared)\n            data.push(1 /* Seq.Next */, shared.addr & 0xffff, shared.addr >> 16);\n        else\n            data.push(0 /* Seq.Done */);\n        return this.data.storeArray(data);\n    }\n    finish(state, isSkip, forcedReduce) {\n        let b = this.builder;\n        let skipID = b.skipRules.indexOf(state.skip);\n        let skipTable = this.skipData[skipID], skipTerms = this.skipInfo[skipID].startTokens;\n        let defaultReduce = state.defaultReduce ? reduceAction(state.defaultReduce, this.skipInfo) : 0;\n        let flags = isSkip ? 1 /* StateFlag.Skipped */ : 0;\n        let skipReduce = -1, shared = null;\n        if (defaultReduce == 0) {\n            if (isSkip)\n                for (const action of state.actions)\n                    if (action instanceof Reduce && action.term.eof)\n                        skipReduce = reduceAction(action.rule, this.skipInfo);\n            if (skipReduce < 0)\n                shared = this.findSharedActions(state);\n        }\n        if (state.set.some(p => p.rule.name.top && p.pos == p.rule.parts.length))\n            flags |= 2 /* StateFlag.Accepting */;\n        let external = [];\n        for (let i = 0; i < state.actions.length + skipTerms.length; i++) {\n            let term = i < state.actions.length ? state.actions[i].term : skipTerms[i - state.actions.length];\n            for (;;) {\n                let orig = b.tokenOrigins[term.name];\n                if (orig && orig.spec) {\n                    term = orig.spec;\n                    continue;\n                }\n                if (orig && (orig.external instanceof ExternalTokenSet))\n                    addToSet(external, orig.external);\n                break;\n            }\n        }\n        let tokenizerMask = 0;\n        for (let i = 0; i < this.tokenizers.length; i++) {\n            let tok = this.tokenizers[i];\n            if (external.includes(tok) || tok.groupID == state.tokenGroup)\n                tokenizerMask |= (1 << i);\n        }\n        let base = state.id * 6 /* ParseState.Size */;\n        this.stateArray[base + 0 /* ParseState.Flags */] = flags;\n        this.stateArray[base + 1 /* ParseState.Actions */] = this.storeActions(defaultReduce ? none : state.actions, skipReduce, shared);\n        this.stateArray[base + 2 /* ParseState.Skip */] = skipTable;\n        this.stateArray[base + 3 /* ParseState.TokenizerMask */] = tokenizerMask;\n        this.stateArray[base + 4 /* ParseState.DefaultReduce */] = defaultReduce;\n        this.stateArray[base + 5 /* ParseState.ForcedReduce */] = forcedReduce;\n    }\n}\nfunction addToProp(term, prop, value) {\n    let cur = term.props[prop];\n    if (!cur || cur.split(\" \").indexOf(value) < 0)\n        term.props[prop] = cur ? cur + \" \" + value : value;\n}\nfunction buildSpecializeTable(spec) {\n    let table = Object.create(null);\n    for (let { value, term, type } of spec) {\n        let code = type == \"specialize\" ? 0 /* Specialize.Specialize */ : 1 /* Specialize.Extend */;\n        table[value] = (term.id << 1) | code;\n    }\n    return table;\n}\nfunction reduceAction(rule, skipInfo, depth = rule.parts.length) {\n    return rule.name.id | 65536 /* Action.ReduceFlag */ |\n        (rule.isRepeatWrap && depth == rule.parts.length ? 131072 /* Action.RepeatFlag */ : 0) |\n        (skipInfo.some(i => i.rule == rule.name) ? 262144 /* Action.StayFlag */ : 0) |\n        (depth << 19 /* Action.ReduceDepthShift */);\n}\nfunction findArray(data, value) {\n    search: for (let i = 0;;) {\n        let next = data.indexOf(value[0], i);\n        if (next == -1 || next + value.length > data.length)\n            break;\n        for (let j = 1; j < value.length; j++) {\n            if (value[j] != data[next + j]) {\n                i = next + 1;\n                continue search;\n            }\n        }\n        return next;\n    }\n    return -1;\n}\nfunction findSkipStates(table, startRules) {\n    let nonSkip = Object.create(null);\n    let work = [];\n    let add = (state) => {\n        if (!nonSkip[state.id]) {\n            nonSkip[state.id] = true;\n            work.push(state);\n        }\n    };\n    for (let state of table)\n        if (state.startRule && startRules.includes(state.startRule))\n            add(state);\n    for (let i = 0; i < work.length; i++) {\n        for (let a of work[i].actions)\n            if (a instanceof Shift)\n                add(a.target);\n        for (let a of work[i].goto)\n            add(a.target);\n    }\n    return (id) => !nonSkip[id];\n}\nclass DataBuilder {\n    constructor() {\n        this.data = [];\n    }\n    storeArray(data) {\n        let found = findArray(this.data, data);\n        if (found > -1)\n            return found;\n        let pos = this.data.length;\n        for (let num of data)\n            this.data.push(num);\n        return pos;\n    }\n    finish() {\n        return Uint16Array.from(this.data);\n    }\n}\n// The goto table maps a start state + a term to a new state, and is\n// used to determine the new state when reducing. Because this allows\n// more more efficient representation and access, unlike the action\n// tables, the goto table is organized by term, with groups of start\n// states that map to a given end state enumerated for each term.\n// Since many terms only have a single valid goto target, this makes\n// it cheaper to look those up.\n//\n// (Unfortunately, though the standard LR parsing mechanism never\n// looks up invalid goto states, the incremental parsing mechanism\n// needs accurate goto information for a state/term pair, so we do\n// need to store state ids even for terms that have only one target.)\n//\n// - First comes the amount of terms in the table\n//\n// - Then, for each term, the offset of the term's data\n//\n// - At these offsets, there's a record for each target state\n//\n//   - Such a record starts with the amount of start states that go to\n//     this target state, shifted one to the left, with the first bit\n//     only set if this is the last record for this term.\n//\n//   - Then follows the target state id\n//\n//   - And then the start state ids\nfunction computeGotoTable(states) {\n    let goto = {};\n    let maxTerm = 0;\n    for (let state of states) {\n        for (let entry of state.goto) {\n            maxTerm = Math.max(entry.term.id, maxTerm);\n            let set = goto[entry.term.id] || (goto[entry.term.id] = {});\n            (set[entry.target.id] || (set[entry.target.id] = [])).push(state.id);\n        }\n    }\n    let data = new DataBuilder;\n    let index = [];\n    let offset = maxTerm + 2; // Offset of the data, taking index size into account\n    for (let term = 0; term <= maxTerm; term++) {\n        let entries = goto[term];\n        if (!entries) {\n            index.push(1);\n            continue;\n        }\n        let termTable = [];\n        let keys = Object.keys(entries);\n        for (let target of keys) {\n            let list = entries[target];\n            termTable.push((target == keys[keys.length - 1] ? 1 : 0) + (list.length << 1));\n            termTable.push(+target);\n            for (let source of list)\n                termTable.push(source);\n        }\n        index.push(data.storeArray(termTable) + offset);\n    }\n    if (index.some(n => n > 0xffff))\n        throw new GenError(\"Goto table too large\");\n    return Uint16Array.from([maxTerm + 1, ...index, ...data.data]);\n}\nclass TokenGroup {\n    constructor(tokens, groupID) {\n        this.tokens = tokens;\n        this.groupID = groupID;\n    }\n    create() { return this.groupID; }\n    createSource() { return String(this.groupID); }\n}\nfunction addToSet(set, value) {\n    if (!set.includes(value))\n        set.push(value);\n}\nfunction buildTokenMasks(groups) {\n    let masks = Object.create(null);\n    for (let group of groups) {\n        let groupMask = 1 << group.groupID;\n        for (let term of group.tokens) {\n            masks[term.id] = (masks[term.id] || 0) | groupMask;\n        }\n    }\n    return masks;\n}\nclass TokenArg {\n    constructor(name, expr, scope) {\n        this.name = name;\n        this.expr = expr;\n        this.scope = scope;\n    }\n}\nclass BuildingRule {\n    constructor(name, start, to, args) {\n        this.name = name;\n        this.start = start;\n        this.to = to;\n        this.args = args;\n    }\n}\nclass TokenSet {\n    constructor(b, ast) {\n        this.b = b;\n        this.ast = ast;\n        this.startState = new State$1;\n        this.built = [];\n        this.building = []; // Used for recursion check\n        this.byDialect = Object.create(null);\n        this.precedenceRelations = [];\n        this.rules = ast ? ast.rules : none;\n        for (let rule of this.rules)\n            b.unique(rule.id);\n    }\n    getToken(expr) {\n        for (let built of this.built)\n            if (built.matches(expr))\n                return built.term;\n        let name = expr.id.name;\n        let rule = this.rules.find(r => r.id.name == name);\n        if (!rule)\n            return null;\n        let { name: nodeName, props, dialect, exported } = this.b.nodeInfo(rule.props, \"d\", name, expr.args, rule.params.length != expr.args.length ? none : rule.params);\n        let term = this.b.makeTerminal(expr.toString(), nodeName, props);\n        if (dialect != null)\n            (this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term);\n        if ((term.nodeType || exported) && rule.params.length == 0) {\n            if (!term.nodeType)\n                term.preserve = true;\n            this.b.namedTerms[exported || name] = term;\n        }\n        this.buildRule(rule, expr, this.startState, new State$1([term]));\n        this.built.push(new BuiltRule(name, expr.args, term));\n        return term;\n    }\n    buildRule(rule, expr, from, to, args = none) {\n        let name = expr.id.name;\n        if (rule.params.length != expr.args.length)\n            this.b.raise(`Incorrect number of arguments for token '${name}'`, expr.start);\n        let building = this.building.find(b => b.name == name && exprsEq(expr.args, b.args));\n        if (building) {\n            if (building.to == to) {\n                from.nullEdge(building.start);\n                return;\n            }\n            let lastIndex = this.building.length - 1;\n            while (this.building[lastIndex].name != name)\n                lastIndex--;\n            this.b.raise(`Invalid (non-tail) recursion in token rules: ${this.building.slice(lastIndex).map(b => b.name).join(\" -> \")}`, expr.start);\n        }\n        this.b.used(rule.id.name);\n        let start = new State$1;\n        from.nullEdge(start);\n        this.building.push(new BuildingRule(name, start, to, expr.args));\n        this.build(this.b.substituteArgs(rule.expr, expr.args, rule.params), start, to, expr.args.map((e, i) => new TokenArg(rule.params[i].name, e, args)));\n        this.building.pop();\n    }\n    build(expr, from, to, args) {\n        if (expr instanceof NameExpression) {\n            let name = expr.id.name, arg = args.find(a => a.name == name);\n            if (arg)\n                return this.build(arg.expr, from, to, arg.scope);\n            let rule;\n            for (let i = 0, lt = this.b.localTokens; i <= lt.length; i++) {\n                let set = i == lt.length ? this.b.tokens : lt[i];\n                rule = set.rules.find(r => r.id.name == name);\n            }\n            if (!rule)\n                return this.b.raise(`Reference to token rule '${expr.id.name}', which isn't found`, expr.start);\n            this.buildRule(rule, expr, from, to, args);\n        }\n        else if (expr instanceof CharClass) {\n            for (let [a, b] of CharClasses[expr.type])\n                from.edge(a, b, to);\n        }\n        else if (expr instanceof ChoiceExpression) {\n            for (let choice of expr.exprs)\n                this.build(choice, from, to, args);\n        }\n        else if (isEmpty(expr)) {\n            from.nullEdge(to);\n        }\n        else if (expr instanceof SequenceExpression) {\n            let conflict = expr.markers.find(c => c.length > 0);\n            if (conflict)\n                this.b.raise(\"Conflict marker in token expression\", conflict[0].start);\n            for (let i = 0; i < expr.exprs.length; i++) {\n                let next = i == expr.exprs.length - 1 ? to : new State$1;\n                this.build(expr.exprs[i], from, next, args);\n                from = next;\n            }\n        }\n        else if (expr instanceof RepeatExpression) {\n            if (expr.kind == \"*\") {\n                let loop = new State$1;\n                from.nullEdge(loop);\n                this.build(expr.expr, loop, loop, args);\n                loop.nullEdge(to);\n            }\n            else if (expr.kind == \"+\") {\n                let loop = new State$1;\n                this.build(expr.expr, from, loop, args);\n                this.build(expr.expr, loop, loop, args);\n                loop.nullEdge(to);\n            }\n            else { // expr.kind == \"?\"\n                from.nullEdge(to);\n                this.build(expr.expr, from, to, args);\n            }\n        }\n        else if (expr instanceof SetExpression) {\n            for (let [a, b] of expr.inverted ? invertRanges(expr.ranges) : expr.ranges)\n                rangeEdges(from, to, a, b);\n        }\n        else if (expr instanceof LiteralExpression) {\n            for (let i = 0; i < expr.value.length; i++) {\n                let ch = expr.value.charCodeAt(i);\n                let next = i == expr.value.length - 1 ? to : new State$1;\n                from.edge(ch, ch + 1, next);\n                from = next;\n            }\n        }\n        else if (expr instanceof AnyExpression) {\n            let mid = new State$1;\n            from.edge(0, 0xDC00, to);\n            from.edge(0xDC00, MAX_CHAR + 1, to);\n            from.edge(0xD800, 0xDC00, mid);\n            mid.edge(0xDC00, 0xE000, to);\n        }\n        else {\n            return this.b.raise(`Unrecognized expression type in token`, expr.start);\n        }\n    }\n    takePrecedences() {\n        let rel = this.precedenceRelations = [];\n        if (this.ast)\n            for (let group of this.ast.precedences) {\n                let prev = [];\n                for (let item of group.items) {\n                    let level = [];\n                    if (item instanceof NameExpression) {\n                        for (let built of this.built)\n                            if (item.args.length ? built.matches(item) : built.id == item.id.name)\n                                level.push(built.term);\n                    }\n                    else {\n                        let id = JSON.stringify(item.value), found = this.built.find(b => b.id == id);\n                        if (found)\n                            level.push(found.term);\n                    }\n                    if (!level.length)\n                        this.b.warn(`Precedence specified for unknown token ${item}`, item.start);\n                    for (let term of level)\n                        addRel(rel, term, prev);\n                    prev = prev.concat(level);\n                }\n            }\n    }\n    precededBy(a, b) {\n        let found = this.precedenceRelations.find(r => r.term == a);\n        return found && found.after.includes(b);\n    }\n    buildPrecTable(softConflicts) {\n        let precTable = [], rel = this.precedenceRelations.slice();\n        // Add entries for soft-conflicting tokens that are in the\n        // precedence table, to make sure they'll appear in the right\n        // order and don't mess up the longer-wins default rule.\n        for (let { a, b, soft } of softConflicts)\n            if (soft) {\n                if (!rel.some(r => r.term == a) || !rel.some(r => r.term == b))\n                    continue;\n                if (soft < 0)\n                    [a, b] = [b, a]; // Now a is longer than b (and should thus take precedence)\n                addRel(rel, b, [a]);\n                addRel(rel, a, []);\n            }\n        add: while (rel.length) {\n            for (let i = 0; i < rel.length; i++) {\n                let record = rel[i];\n                if (record.after.every(t => precTable.includes(t.id))) {\n                    precTable.push(record.term.id);\n                    if (rel.length == 1)\n                        break add;\n                    rel[i] = rel.pop();\n                    continue add;\n                }\n            }\n            this.b.raise(`Cyclic token precedence relation between ${rel.map(r => r.term).join(\", \")}`);\n        }\n        return precTable;\n    }\n}\nclass MainTokenSet extends TokenSet {\n    constructor() {\n        super(...arguments);\n        this.explicitConflicts = [];\n    }\n    getLiteral(expr) {\n        let id = JSON.stringify(expr.value);\n        for (let built of this.built)\n            if (built.id == id)\n                return built.term;\n        let name = null, props = {}, dialect = null, exported = null;\n        let decl = this.ast ? this.ast.literals.find(l => l.literal == expr.value) : null;\n        if (decl)\n            ({ name, props, dialect, exported } = this.b.nodeInfo(decl.props, \"da\", expr.value));\n        let term = this.b.makeTerminal(id, name, props);\n        if (dialect != null)\n            (this.byDialect[dialect] || (this.byDialect[dialect] = [])).push(term);\n        if (exported)\n            this.b.namedTerms[exported] = term;\n        this.build(expr, this.startState, new State$1([term]), none);\n        this.built.push(new BuiltRule(id, none, term));\n        return term;\n    }\n    takeConflicts() {\n        var _a;\n        let resolve = (expr) => {\n            if (expr instanceof NameExpression) {\n                for (let built of this.built)\n                    if (built.matches(expr))\n                        return built.term;\n            }\n            else {\n                let id = JSON.stringify(expr.value), found = this.built.find(b => b.id == id);\n                if (found)\n                    return found.term;\n            }\n            this.b.warn(`Precedence specified for unknown token ${expr}`, expr.start);\n            return null;\n        };\n        for (let c of ((_a = this.ast) === null || _a === void 0 ? void 0 : _a.conflicts) || []) {\n            let a = resolve(c.a), b = resolve(c.b);\n            if (a && b) {\n                if (a.id < b.id)\n                    [a, b] = [b, a];\n                this.explicitConflicts.push({ a, b });\n            }\n        }\n    }\n    // Token groups are a mechanism for allowing conflicting (matching\n    // overlapping input, without an explicit precedence being given)\n    // tokens to exist in a grammar _if_ they don't occur in the same\n    // place (aren't used in the same states).\n    //\n    // States that use tokens that conflict will raise an error when any\n    // of the conflicting pairs of tokens both occur in that state.\n    // Otherwise, they are assigned a token group, which includes all\n    // the potentially-conflicting tokens they use. If there's already a\n    // group that doesn't have any conflicts with those tokens, that is\n    // reused, otherwise a new group is created.\n    //\n    // So each state has zero or one token groups, and each conflicting\n    // token may belong to one or more groups. Tokens get assigned a\n    // 16-bit bitmask with the groups they belong to set to 1 (all-1s\n    // for non-conflicting tokens). When tokenizing, that mask is\n    // compared to the current state's group (again using all-1s for\n    // group-less states) to determine whether a token is applicable for\n    // this state.\n    //\n    // Extended/specialized tokens are treated as their parent token for\n    // this purpose.\n    buildTokenGroups(states, skipInfo, startID) {\n        let tokens = this.startState.compile();\n        if (tokens.accepting.length)\n            this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`, this.rules.find(r => r.id.name == tokens.accepting[0].name).start);\n        if (/\\btokens\\b/.test(verbose))\n            console.log(tokens.toString());\n        // If there is a precedence specified for the pair, the conflict is resolved\n        let allConflicts = tokens.findConflicts(checkTogether(states, this.b, skipInfo))\n            .filter(({ a, b }) => !this.precededBy(a, b) && !this.precededBy(b, a));\n        for (let { a, b } of this.explicitConflicts) {\n            if (!allConflicts.some(c => c.a == a && c.b == b))\n                allConflicts.push(new Conflict$1(a, b, 0, \"\", \"\"));\n        }\n        let softConflicts = allConflicts.filter(c => c.soft), conflicts = allConflicts.filter(c => !c.soft);\n        let errors = [];\n        let groups = [];\n        for (let state of states) {\n            if (state.defaultReduce || state.tokenGroup > -1)\n                continue;\n            // Find potentially-conflicting terms (in terms) and the things\n            // they conflict with (in conflicts), and raise an error if\n            // there's a token conflict directly in this state.\n            let terms = [], incompatible = [];\n            let skip = skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens;\n            for (let term of skip)\n                if (state.actions.some(a => a.term == term))\n                    this.b.raise(`Use of token ${term.name} conflicts with skip rule`);\n            let stateTerms = [];\n            for (let i = 0; i < state.actions.length + (skip ? skip.length : 0); i++) {\n                let term = i < state.actions.length ? state.actions[i].term : skip[i - state.actions.length];\n                let orig = this.b.tokenOrigins[term.name];\n                if (orig && orig.spec)\n                    term = orig.spec;\n                else if (orig && orig.external)\n                    continue;\n                addToSet(stateTerms, term);\n            }\n            if (stateTerms.length == 0)\n                continue;\n            for (let term of stateTerms) {\n                for (let conflict of conflicts) {\n                    let conflicting = conflict.a == term ? conflict.b : conflict.b == term ? conflict.a : null;\n                    if (!conflicting)\n                        continue;\n                    if (stateTerms.includes(conflicting) && !errors.some(e => e.conflict == conflict)) {\n                        let example = conflict.exampleA ? ` (example: ${JSON.stringify(conflict.exampleA)}${conflict.exampleB ? ` vs ${JSON.stringify(conflict.exampleB)}` : \"\"})` : \"\";\n                        errors.push({\n                            error: `Overlapping tokens ${term.name} and ${conflicting.name} used in same context${example}\\n` +\n                                `After: ${state.set[0].trail()}`,\n                            conflict\n                        });\n                    }\n                    addToSet(terms, term);\n                    addToSet(incompatible, conflicting);\n                }\n            }\n            let tokenGroup = null;\n            for (let group of groups) {\n                if (incompatible.some(term => group.tokens.includes(term)))\n                    continue;\n                for (let term of terms)\n                    addToSet(group.tokens, term);\n                tokenGroup = group;\n                break;\n            }\n            if (!tokenGroup) {\n                tokenGroup = new TokenGroup(terms, groups.length + startID);\n                groups.push(tokenGroup);\n            }\n            state.tokenGroup = tokenGroup.groupID;\n        }\n        if (errors.length)\n            this.b.raise(errors.map(e => e.error).join(\"\\n\\n\"));\n        if (groups.length + startID > 16)\n            this.b.raise(`Too many different token groups (${groups.length}) to represent them as a 16-bit bitfield`);\n        let precTable = this.buildPrecTable(softConflicts);\n        return {\n            tokenGroups: groups,\n            tokenPrec: precTable,\n            tokenData: tokens.toArray(buildTokenMasks(groups), precTable)\n        };\n    }\n}\nclass LocalTokenSet extends TokenSet {\n    constructor(b, ast) {\n        super(b, ast);\n        this.fallback = null;\n        if (ast.fallback)\n            b.unique(ast.fallback.id);\n    }\n    getToken(expr) {\n        let term = null;\n        if (this.ast.fallback && this.ast.fallback.id.name == expr.id.name) {\n            if (expr.args.length)\n                this.b.raise(`Incorrect number of arguments for ${expr.id.name}`, expr.start);\n            if (!this.fallback) {\n                let { name: nodeName, props, exported } = this.b.nodeInfo(this.ast.fallback.props, \"\", expr.id.name, none, none);\n                let term = this.fallback = this.b.makeTerminal(expr.id.name, nodeName, props);\n                if (term.nodeType || exported) {\n                    if (!term.nodeType)\n                        term.preserve = true;\n                    this.b.namedTerms[exported || expr.id.name] = term;\n                }\n                this.b.used(expr.id.name);\n            }\n            term = this.fallback;\n        }\n        else {\n            term = super.getToken(expr);\n        }\n        if (term && !this.b.tokenOrigins[term.name])\n            this.b.tokenOrigins[term.name] = { group: this };\n        return term;\n    }\n    buildLocalGroup(states, skipInfo, id) {\n        let tokens = this.startState.compile();\n        if (tokens.accepting.length)\n            this.b.raise(`Grammar contains zero-length tokens (in '${tokens.accepting[0].name}')`, this.rules.find(r => r.id.name == tokens.accepting[0].name).start);\n        for (let { a, b, exampleA } of tokens.findConflicts(() => true)) {\n            if (!this.precededBy(a, b) && !this.precededBy(b, a))\n                this.b.raise(`Overlapping tokens ${a.name} and ${b.name} in local token group${exampleA ? ` (example: ${JSON.stringify(exampleA)})` : ''}`);\n        }\n        for (let state of states) {\n            if (state.defaultReduce)\n                continue;\n            // See if this state uses any of the tokens in this group, and\n            // if so, make sure it *only* uses tokens from this group.\n            let usesThis = null;\n            let usesOther = skipInfo[this.b.skipRules.indexOf(state.skip)].startTokens[0];\n            for (let { term } of state.actions) {\n                let orig = this.b.tokenOrigins[term.name];\n                if ((orig === null || orig === void 0 ? void 0 : orig.group) == this)\n                    usesThis = term;\n                else\n                    usesOther = term;\n            }\n            if (usesThis) {\n                if (usesOther)\n                    this.b.raise(`Tokens from a local token group used together with other tokens (${usesThis.name} with ${usesOther.name})`);\n                state.tokenGroup = id;\n            }\n        }\n        let precTable = this.buildPrecTable(none);\n        let tokenData = tokens.toArray({ [id]: 65535 /* Seq.End */ }, precTable);\n        let precOffset = tokenData.length;\n        let fullData = new Uint16Array(tokenData.length + precTable.length + 1);\n        fullData.set(tokenData, 0);\n        fullData.set(precTable, precOffset);\n        fullData[fullData.length - 1] = 65535 /* Seq.End */;\n        return {\n            groupID: id,\n            create: () => new LocalTokenGroup(fullData, precOffset, this.fallback ? this.fallback.id : undefined),\n            createSource: importName => `new ${importName(\"LocalTokenGroup\", \"@lezer/lr\")}(${encodeArray(fullData)}, ${precOffset}${this.fallback ? `, ${this.fallback.id}` : ''})`\n        };\n    }\n}\nfunction checkTogether(states, b, skipInfo) {\n    let cache = Object.create(null);\n    function hasTerm(state, term) {\n        return state.actions.some(a => a.term == term) ||\n            skipInfo[b.skipRules.indexOf(state.skip)].startTokens.includes(term);\n    }\n    return (a, b) => {\n        if (a.id < b.id)\n            [a, b] = [b, a];\n        let key = a.id | (b.id << 16), cached = cache[key];\n        if (cached != null)\n            return cached;\n        return cache[key] = states.some(state => hasTerm(state, a) && hasTerm(state, b));\n    };\n}\nfunction invertRanges(ranges) {\n    let pos = 0, result = [];\n    for (let [a, b] of ranges) {\n        if (a > pos)\n            result.push([pos, a]);\n        pos = b;\n    }\n    if (pos <= MAX_CODE)\n        result.push([pos, MAX_CODE + 1]);\n    return result;\n}\nconst ASTRAL = 0x10000, GAP_START = 0xd800, GAP_END = 0xe000, MAX_CODE = 0x10ffff;\nconst LOW_SURR_B = 0xdc00, HIGH_SURR_B = 0xdfff;\n// Create intermediate states for astral characters in a range, if\n// necessary, since the tokenizer acts on UTF16 characters\nfunction rangeEdges(from, to, low, hi) {\n    if (low < ASTRAL) {\n        if (low < GAP_START)\n            from.edge(low, Math.min(hi, GAP_START), to);\n        if (hi > GAP_END)\n            from.edge(Math.max(low, GAP_END), Math.min(hi, MAX_CHAR + 1), to);\n        low = ASTRAL;\n    }\n    if (hi <= ASTRAL)\n        return;\n    let lowStr = String.fromCodePoint(low), hiStr = String.fromCodePoint(hi - 1);\n    let lowA = lowStr.charCodeAt(0), lowB = lowStr.charCodeAt(1);\n    let hiA = hiStr.charCodeAt(0), hiB = hiStr.charCodeAt(1);\n    if (lowA == hiA) { // Share the first char code\n        let hop = new State$1;\n        from.edge(lowA, lowA + 1, hop);\n        hop.edge(lowB, hiB + 1, to);\n    }\n    else {\n        let midStart = lowA, midEnd = hiA;\n        if (lowB > LOW_SURR_B) {\n            midStart++;\n            let hop = new State$1;\n            from.edge(lowA, lowA + 1, hop);\n            hop.edge(lowB, HIGH_SURR_B + 1, to);\n        }\n        if (hiB < HIGH_SURR_B) {\n            midEnd--;\n            let hop = new State$1;\n            from.edge(hiA, hiA + 1, hop);\n            hop.edge(LOW_SURR_B, hiB + 1, to);\n        }\n        if (midStart <= midEnd) {\n            let hop = new State$1;\n            from.edge(midStart, midEnd + 1, hop);\n            hop.edge(LOW_SURR_B, HIGH_SURR_B + 1, to);\n        }\n    }\n}\nfunction isEmpty(expr) {\n    return expr instanceof SequenceExpression && expr.exprs.length == 0;\n}\nfunction gatherExtTokens(b, tokens) {\n    let result = Object.create(null);\n    for (let token of tokens) {\n        b.unique(token.id);\n        let { name, props, dialect } = b.nodeInfo(token.props, \"d\", token.id.name);\n        let term = b.makeTerminal(token.id.name, name, props);\n        if (dialect != null)\n            (b.tokens.byDialect[dialect] || (b.tokens.byDialect[dialect] = [])).push(term);\n        b.namedTerms[token.id.name] = result[token.id.name] = term;\n    }\n    return result;\n}\nfunction findExtToken(b, tokens, expr) {\n    let found = tokens[expr.id.name];\n    if (!found)\n        return null;\n    if (expr.args.length)\n        b.raise(\"External tokens cannot take arguments\", expr.args[0].start);\n    b.used(expr.id.name);\n    return found;\n}\nfunction addRel(rel, term, after) {\n    let found = rel.findIndex(r => r.term == term);\n    if (found < 0)\n        rel.push({ term, after });\n    else\n        rel[found] = { term, after: rel[found].after.concat(after) };\n}\nclass ExternalTokenSet {\n    constructor(b, ast) {\n        this.b = b;\n        this.ast = ast;\n        this.tokens = gatherExtTokens(b, ast.tokens);\n        for (let name in this.tokens)\n            this.b.tokenOrigins[this.tokens[name].name] = { external: this };\n    }\n    getToken(expr) { return findExtToken(this.b, this.tokens, expr); }\n    create() {\n        return this.b.options.externalTokenizer(this.ast.id.name, this.b.termTable);\n    }\n    createSource(importName) {\n        let { source, id: { name } } = this.ast;\n        return importName(name, source);\n    }\n}\nclass ExternalSpecializer {\n    constructor(b, ast) {\n        this.b = b;\n        this.ast = ast;\n        this.term = null;\n        this.tokens = gatherExtTokens(b, ast.tokens);\n    }\n    finish() {\n        let terms = this.b.normalizeExpr(this.ast.token);\n        if (terms.length != 1 || terms[0].terms.length != 1 || !terms[0].terms[0].terminal)\n            this.b.raise(`The token expression to '@external ${this.ast.type}' must resolve to a token`, this.ast.token.start);\n        this.term = terms[0].terms[0];\n        for (let name in this.tokens)\n            this.b.tokenOrigins[this.tokens[name].name] = { spec: this.term, external: this };\n    }\n    getToken(expr) { return findExtToken(this.b, this.tokens, expr); }\n}\nfunction inlineRules(rules, preserve) {\n    for (let pass = 0;; pass++) {\n        let inlinable = Object.create(null), found;\n        if (pass == 0)\n            for (let rule of rules) {\n                if (rule.name.inline && !inlinable[rule.name.name]) {\n                    let group = rules.filter(r => r.name == rule.name);\n                    if (group.some(r => r.parts.includes(rule.name)))\n                        continue;\n                    found = inlinable[rule.name.name] = group;\n                }\n            }\n        for (let i = 0; i < rules.length; i++) {\n            let rule = rules[i];\n            if (!rule.name.interesting && !rule.parts.includes(rule.name) && rule.parts.length < 3 &&\n                !preserve.includes(rule.name) &&\n                (rule.parts.length == 1 || rules.every(other => other.skip == rule.skip || !other.parts.includes(rule.name))) &&\n                !rule.parts.some(p => !!inlinable[p.name]) &&\n                !rules.some((r, j) => j != i && r.name == rule.name))\n                found = inlinable[rule.name.name] = [rule];\n        }\n        if (!found)\n            return rules;\n        let newRules = [];\n        for (let rule of rules) {\n            if (inlinable[rule.name.name])\n                continue;\n            if (!rule.parts.some(p => !!inlinable[p.name])) {\n                newRules.push(rule);\n                continue;\n            }\n            function expand(at, conflicts, parts) {\n                if (at == rule.parts.length) {\n                    newRules.push(new Rule(rule.name, parts, conflicts, rule.skip));\n                    return;\n                }\n                let next = rule.parts[at], replace = inlinable[next.name];\n                if (!replace) {\n                    expand(at + 1, conflicts.concat(rule.conflicts[at + 1]), parts.concat(next));\n                    return;\n                }\n                for (let r of replace)\n                    expand(at + 1, conflicts.slice(0, conflicts.length - 1)\n                        .concat(conflicts[at].join(r.conflicts[0]))\n                        .concat(r.conflicts.slice(1, r.conflicts.length - 1))\n                        .concat(rule.conflicts[at + 1].join(r.conflicts[r.conflicts.length - 1])), parts.concat(r.parts));\n            }\n            expand(0, [rule.conflicts[0]], []);\n        }\n        rules = newRules;\n    }\n}\nfunction mergeRules(rules) {\n    let merged = Object.create(null), found;\n    for (let i = 0; i < rules.length;) {\n        let groupStart = i;\n        let name = rules[i++].name;\n        while (i < rules.length && rules[i].name == name)\n            i++;\n        let size = i - groupStart;\n        if (name.interesting)\n            continue;\n        for (let j = i; j < rules.length;) {\n            let otherStart = j, otherName = rules[j++].name;\n            while (j < rules.length && rules[j].name == otherName)\n                j++;\n            if (j - otherStart != size || otherName.interesting)\n                continue;\n            let match = true;\n            for (let k = 0; k < size && match; k++) {\n                let a = rules[groupStart + k], b = rules[otherStart + k];\n                if (a.cmpNoName(b) != 0)\n                    match = false;\n            }\n            if (match)\n                found = merged[name.name] = otherName;\n        }\n    }\n    if (!found)\n        return rules;\n    let newRules = [];\n    for (let rule of rules)\n        if (!merged[rule.name.name]) {\n            newRules.push(rule.parts.every(p => !merged[p.name]) ? rule :\n                new Rule(rule.name, rule.parts.map(p => merged[p.name] || p), rule.conflicts, rule.skip));\n        }\n    return newRules;\n}\nfunction simplifyRules(rules, preserve) {\n    return mergeRules(inlineRules(rules, preserve));\n}\n/**\nBuild an in-memory parser instance for a given grammar. This is\nmostly useful for testing. If your grammar uses external\ntokenizers, you'll have to provide the `externalTokenizer` option\nfor the returned parser to be able to parse anything.\n*/\nfunction buildParser(text, options = {}) {\n    let builder = new Builder(text, options), parser = builder.getParser();\n    parser.termTable = builder.termTable;\n    return parser;\n}\nconst KEYWORDS = [\"await\", \"break\", \"case\", \"catch\", \"continue\", \"debugger\", \"default\", \"do\", \"else\", \"finally\",\n    \"for\", \"function\", \"if\", \"return\", \"switch\", \"throw\", \"try\", \"var\", \"while\", \"with\",\n    \"null\", \"true\", \"false\", \"instanceof\", \"typeof\", \"void\", \"delete\", \"new\", \"in\", \"this\",\n    \"const\", \"class\", \"extends\", \"export\", \"import\", \"super\", \"enum\", \"implements\", \"interface\",\n    \"let\", \"package\", \"private\", \"protected\", \"public\", \"static\", \"yield\", \"require\"];\n/**\nBuild the code that represents the parser tables for a given\ngrammar description. The `parser` property in the return value\nholds the main file that exports the `Parser` instance. The\n`terms` property holds a declaration file that defines constants\nfor all of the named terms in grammar, holding their ids as value.\nThis is useful when external code, such as a tokenizer, needs to\nbe able to use these ids. It is recommended to run a tree-shaking\nbundler when importing this file, since you usually only need a\nhandful of the many terms in your code.\n*/\nfunction buildParserFile(text, options = {}) {\n    return new Builder(text, options).getParserFile();\n}\nfunction ignored(name) {\n    let first = name[0];\n    return first == \"_\" || first.toUpperCase() != first;\n}\nfunction isExported(rule) {\n    return rule.props.some(p => p.at && p.name == \"export\");\n}\n\nexport { GenError, buildParser, buildParserFile };\n"],"names":["Node","constructor","start","this","GrammarDeclaration","rules","topRules","tokens","localTokens","context","externalTokens","externalSpecializers","externalPropSources","precedences","mainSkip","scopedSkip","dialects","externalProps","autoDelim","super","toString","Object","values","join","RuleDeclaration","id","props","params","expr","name","length","PrecDeclaration","items","TokenPrecDeclaration","TokenConflictDeclaration","a","b","TokenDeclaration","conflicts","literals","LocalTokenDeclaration","fallback","LiteralDeclaration","literal","ContextDeclaration","source","ExternalTokenDeclaration","ExternalSpecializeDeclaration","type","token","ExternalPropSourceDeclaration","ExternalPropDeclaration","externalID","Identifier","Expression","walk","f","eq","_other","prototype","prec","NameExpression","args","other","exprsEq","walkExprs","SpecializeExpression","content","Prop","eqProps","exprEq","InlineRuleExpression","rule","oRule","ChoiceExpression","exprs","map","e","maybeParens","SequenceExpression","markers","empty","every","m","i","om","x","ConflictMarker","RepeatExpression","kind","LiteralExpression","value","JSON","stringify","SetExpression","ranges","inverted","String","fromCodePoint","y","AnyExpression","result","slice","push","CharClasses","asciiLetter","asciiLowercase","asciiUppercase","digit","whitespace","eof","CharClass","at","v","test","p","PropPart","node","parent","GenError","Error","hasProps","_p","termHash","Term","flags","nodeName","hash","nodeType","top","repeated","terminal","error","interesting","preserve","inline","cmp","TermSet","terms","names","create","tops","term","makeTop","makeTerminal","makeNonTerminal","makeRepeat","uniqueName","cur","finish","filter","t","some","r","parts","includes","nodeTypes","nextID","minRepeatTerm","maxTerm","cmpSet","diff","none$3","Conflicts","precedence","ambigGroups","cut","none","Math","max","union","sort","ruleID","Rule","skip","cmpNoName","reduce","s","isRepeatWrap","sameReduce","MAX_CHAR","Edge","from","to","target","charFor","n","fromCharCode","minimize","states","partition","byAccepting","state","ids","accepting","group","split","newPartition","groups","isEquivalent","applyMinimization","edges","eA","eB","edge","stateID","State$1","State","nullEdge","compile","labeled","localID","startState","explore","closure","newState","out","transitions","mergeEdges","merged","targets","seen","sameSet$1","findConflicts","occurTogether","cycleTerms","add","soft","aEdges","bEdges","found","find","c","Conflict$1","exampleFromEdges","reachable","j","es","hasCycle","orig","concat","work","table","Map","haveCycle","entry","get","set","next","pop","toArray","groupMasks","offsets","data","acceptEnd","stateMask","indexOf","pow","Uint16Array","mask","Conflict","exampleA","exampleB","str","elts","elt","MergedEdge","separate","word","_","none$2","Input","string","fileName","end","lineInfo","pos","line","ch","message","msg","posInfo","info","raise","match","re","exec","readString","lastIndex","eat","unexpected","expect","val","parse","parseGrammar","input","external","specialized","propSources","sawTop","parseRule","parseIdent","parseTokens","parseLocalTokens","parseExternalTokens","parseExternalProp","parseExternalSpecialize","parseExternalPropSource","first","parsePrecedence","parseBracedExpr","named","parseProps","parseProp","parseExprChoice","SET_MARKER","parseExprInner","invert","unescaped","replace","code","codePointAt","addRange","charCodeAt","hasOwnProperty","cls","parseArgs","parseExprSuffix","endOfSequence","parseExprSequence","localStart","markerType","ms","left","tokenRules","parseTokenPrecedence","parseTokenConflict","parseExternalTokenSet","point","all","u1","u2","u3","single","unknown","parseInt","hashString","h","verbose","process","env","LOG","timing","time","label","t0","Date","now","console","log","toFixed","_label","Pos","ahead","ambigAhead","skipAhead","via","advance","cmpStr","eqSimple","splice","sameSet","trail","maxLen","reverse","addOrigins","conflictsAt","compareRepeatPrec","posB","termsAhead","after","cont","addTo","eqSet","Shift","Reduce","matches","mapping","mapped","hashPositions","ConflictContext","startRule","actions","actionPositions","goto","tokenGroup","defaultReduce","_actionsByTerm","g","addActionInner","positions","check","action","fullPos","actionFullPos","actionConflicts","addAction","conflict","conflictPos","findConflictShiftSource","findConflictOrigin","getGoto","hasSet","actionsByTerm","dThis","dOther","added","redo","addFor","existing","none$1","origIndex","findIndex","array","computeFirstSets","change","nt","startLen","part","Core","root","hist","unshift","repeat","p2","termAfter","path","Set","hasMatch","inner","has","buildFullAutomaton","startTerms","statesBySetHash","cores","getState","core","coreHash","byHash","known","forHash","startTerm","startSkip","filled","byTerm","byTermPos","atEnd","index","applyCut","replaced","count","canMerge","setB","setA","a1","a2","mergeStates","newStates","newID","Group","origin","member","members","samePosSet","collapseAutomaton","assignGroups","spill","groupIndex","pass","idA","idB","mergeIdentical","didMerge","finishAutomaton","full","digitToChar","encode","low","rest","encodeArray","Parts","ensureConflicts","otherConflicts","withConflicts","BuiltRule","matchesRepeat","Builder","text","options","tokenOrigins","built","ruleNames","namespaces","namedTerms","termTable","knownProps","dynamicRulePrecedences","definedGroups","astRules","currentSkip","ast","NP","NodeProp","prop","perNode","externalProp","d","MainTokenSet","LocalTokenSet","ext","ExternalTokenSet","decl","ExternalSpecializer","noSkip","newName","defineRule","scoped","sc","isEmpty","unique","skipRules","normalizeExpr","used","nodeInfo","isExported","buildRule","warn","takePrecedences","takeConflicts","lt","defineGroup","checkGroups","base","prepareParser","simplifyRules","termNames","skipInfo","startTokens","fullTable","grp","buildLocalGroup","tokenGroups","tokenPrec","tokenData","buildTokenGroups","skipState","findSkipStates","buildSpecializeTable","tokStart","tokenizer","tokenizers","DataBuilder","skipData","storeArray","Uint32Array","forceReductions","computeForceReductions","finishCx","FinishStateContext","byDialect","dynamicPrecedences","precTable","nodeProps","skippedTypes","gatherNodeProps","stateData","computeGotoTable","nodeNames","repeatNodeCount","getParser","rawNodeProps","rawSpecialized","externalSpecializer","stack","extend","deserialize","version","externalPropSource","undefined","skippedNodes","tok","contextTracker","getParserFile","rawTokenizers","rawDialects","mod","moduleStyle","gen","head","imports","imported","defined","KEYWORDS","exportName","getName","prefix","importName","spec","src","varName","lrParser","createSource","propID","serializePropValue","specializationTableString","keys","key","specHead","ts","typeScript","tableName","parserStr","includeNames","parser","gatherNonSkippedNodes","forEach","notSkipped","rec","tag","reductions","candidates","gotoEdges","o","parents","length1Reductions","createsCycle","parentIntersection","reduceAction","setSize","done","substituteArgs","arg","substituteArgsInProps","substituteInValue","conflictsFor","here","marker","precs","item","choices","choice","resolve","getToken","normalizeRepeat","normalizeSequence","builder","complete","endConflicts","getLiteral","resolveSpecialization","dynamicPrec","explicitInline","exported","registerDynamicPrec","allow","defaultName","defaultProps","ignored","dialect","builtin","finishProp","dialectID","delim","findDelimiters","addToProp","param","sp","findToken","lastToken","brackets","bracket","firstToken","_a","recur","getNamed","MinSharedActions","stateArray","sharedActions","findSharedActions","shared","scratch","fill","addr","storeActions","skipReduce","isSkip","forcedReduce","skipID","skipTable","skipTerms","addToSet","tokenizerMask","groupID","depth","findArray","search","startRules","nonSkip","num","offset","entries","list","TokenGroup","buildTokenMasks","masks","groupMask","TokenArg","scope","BuildingRule","TokenSet","building","precedenceRelations","build","loop","invertRanges","rangeEdges","mid","rel","prev","level","addRel","precededBy","buildPrecTable","softConflicts","record","arguments","explicitConflicts","l","startID","allConflicts","checkTogether","errors","incompatible","stateTerms","conflicting","example","usesThis","usesOther","precOffset","fullData","cache","hasTerm","cached","MAX_CODE","ASTRAL","GAP_START","GAP_END","LOW_SURR_B","HIGH_SURR_B","hi","min","lowStr","hiStr","lowA","lowB","hiA","hiB","hop","midStart","midEnd","gatherExtTokens","findExtToken","externalTokenizer","inlineRules","inlinable","newRules","expand","mergeRules","groupStart","size","otherStart","otherName","k","buildParser","buildParserFile","toUpperCase"],"sourceRoot":""}